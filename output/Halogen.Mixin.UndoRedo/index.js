// Generated by psc-make version 0.6.8

/**
 *  | This module provides a generic undo/redo capability.
 */
"use strict";
var Prelude = require("Prelude");
var Data_Maybe = require("Data.Maybe");
var Data_Tuple = require("Data.Tuple");

/**
 *  | Adds two new input types:
 *  |
 *  | - `Undo` - move to the previous state
 *  | - `Redo` - move to the next state
 */
var Undo = (function () {
    function Undo() {

    };
    Undo.value = new Undo();
    return Undo;
})();

/**
 *  | Adds two new input types:
 *  |
 *  | - `Undo` - move to the previous state
 *  | - `Redo` - move to the next state
 */
var Redo = (function () {
    function Redo() {

    };
    Redo.value = new Redo();
    return Redo;
})();
var Empty = (function () {
    function Empty() {

    };
    Empty.value = new Empty();
    return Empty;
})();
var Push = (function () {
    function Push(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Push.create = function (value0) {
        return function (value1) {
            return new Push(value0, value1);
        };
    };
    return Push;
})();

/**
 *  | Modifies the state type to include its _past_ and _future_.
 */
var UndoRedoState = (function () {
    function UndoRedoState(value0, value1, value2) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
    };
    UndoRedoState.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return new UndoRedoState(value0, value1, value2);
            };
        };
    };
    return UndoRedoState;
})();

/**
 *  | This type class identifies those input types which support the Undo and Redo actions
 */
var SupportsUndoRedo = function (fromUndoRedo, toUndoRedo) {
    this.fromUndoRedo = fromUndoRedo;
    this.toUndoRedo = toUndoRedo;
};

/**
 *  | Create a state with no past and no future
 */
var undoRedoState = function (s) {
    return new UndoRedoState(Empty.value, s, Empty.value);
};

/**
 *  | This type class identifies those input types which support the Undo and Redo actions
 */
var toUndoRedo = function (dict) {
    return dict.toUndoRedo;
};
var pop = function (_975) {
    if (_975 instanceof Push) {
        return new Data_Maybe.Just(new Data_Tuple.Tuple(_975.value0, _975.value1));
    };
    if (_975 instanceof Empty) {
        return Data_Maybe.Nothing.value;
    };
    throw new Error("Failed pattern match");
};

/**
 *  | Lift a step function to support the undo and redo operations.
 *  |
 *  | The view should use the `canUndo` and `canRedo` functions to determine whether or not
 *  | to enable the corresponding controls.
 */
var withUndoRedo = function (__dict_SupportsUndoRedo_0) {
    return function (f) {
        return function (st) {
            return function (i) {
                var withUndo$prime = function (_981) {
                    return function (_982) {
                        if (_982 instanceof Data_Maybe.Just && _982.value0 instanceof Undo) {
                            return Data_Maybe.fromMaybe(_981)(Prelude[">>="](Data_Maybe.bindMaybe)(pop(_981.value0))(function (_53) {
                                return Prelude["return"](Data_Maybe.monadMaybe)(new UndoRedoState(_53.value1, _53.value0, new Push(_981.value1, _981.value2)));
                            }));
                        };
                        if (_982 instanceof Data_Maybe.Just && _982.value0 instanceof Redo) {
                            return Data_Maybe.fromMaybe(_981)(Prelude[">>="](Data_Maybe.bindMaybe)(pop(_981.value2))(function (_54) {
                                return Prelude["return"](Data_Maybe.monadMaybe)(new UndoRedoState(new Push(_981.value1, _981.value0), _54.value0, _54.value1));
                            }));
                        };
                        if (_982 instanceof Data_Maybe.Nothing) {
                            return new UndoRedoState(new Push(_981.value1, _981.value0), f(_981.value1)(i), Empty.value);
                        };
                        throw new Error("Failed pattern match");
                    };
                };
                return withUndo$prime(st)(toUndoRedo(__dict_SupportsUndoRedo_0)(i));
            };
        };
    };
};
var $$null = function (_977) {
    if (_977 instanceof Empty) {
        return true;
    };
    return false;
};

/**
 *  | Get the state at the current time
 */
var getState = function (_980) {
    return _980.value1;
};

/**
 *  | This type class identifies those input types which support the Undo and Redo actions
 */
var fromUndoRedo = function (dict) {
    return dict.fromUndoRedo;
};

/**
 *  | The redo action
 */
var redo = function (__dict_SupportsUndoRedo_1) {
    return fromUndoRedo(__dict_SupportsUndoRedo_1)(Redo.value);
};

/**
 *  | The undo action
 */
var undo = function (__dict_SupportsUndoRedo_2) {
    return fromUndoRedo(__dict_SupportsUndoRedo_2)(Undo.value);
};
var depth = function (_976) {
    if (_976 instanceof Empty) {
        return 0;
    };
    if (_976 instanceof Push) {
        return 1 + depth(_976.value1);
    };
    throw new Error("Failed pattern match");
};

/**
 *  | `true` if the state supports the undo operation. 
 */
var canUndo = function (_978) {
    return !$$null(_978.value0);
};

/**
 *  | `true` if the state supports the redo operation.
 */
var canRedo = function (_979) {
    return !$$null(_979.value2);
};
module.exports = {
    Undo: Undo, 
    Redo: Redo, 
    SupportsUndoRedo: SupportsUndoRedo, 
    withUndoRedo: withUndoRedo, 
    undoRedoState: undoRedoState, 
    getState: getState, 
    canRedo: canRedo, 
    canUndo: canUndo, 
    redo: redo, 
    undo: undo, 
    toUndoRedo: toUndoRedo, 
    fromUndoRedo: fromUndoRedo
};
