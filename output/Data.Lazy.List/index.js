// Generated by psc-make version 0.6.8

/**
 *  | Lazy linked-lists
 */
"use strict";
var Prelude = require("Prelude");
var Data_Lazy = require("Data.Lazy");
var Data_Array = require("Data.Array");
var Data_Foldable = require("Data.Foldable");
var Data_Monoid = require("Data.Monoid");
var Data_Traversable = require("Data.Traversable");
function showItems (l) {  return l.join(', ');};

/**
 *  | A lazy linked list type.
 *  | 
 *  | This type is strict in its head element, but lazy in its tail.
 *  |
 *  | Various operations on lazy lists require evaluation of the entire list,
 *  | so care is needed when defining and using infinite lists.
 */
var Nil = (function () {
    function Nil() {

    };
    Nil.value = new Nil();
    return Nil;
})();

/**
 *  | A lazy linked list type.
 *  | 
 *  | This type is strict in its head element, but lazy in its tail.
 *  |
 *  | Various operations on lazy lists require evaluation of the entire list,
 *  | so care is needed when defining and using infinite lists.
 */
var Cons = (function () {
    function Cons(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Cons.create = function (value0) {
        return function (value1) {
            return new Cons(value0, value1);
        };
    };
    return Cons;
})();
var $less$dot$greater = function (_738) {
    return function (_739) {
        if (_738 instanceof Nil) {
            return Data_Lazy.force(_739);
        };
        if (_738 instanceof Cons) {
            return new Cons(_738.value0, Prelude["<$>"](Data_Lazy.functorLazy)(function (xs$prime) {
                return $less$dot$greater(xs$prime)(_739);
            })(_738.value1));
        };
        throw new Error("Failed pattern match");
    };
};

/**
 *  | Convert a lazy list into an immutable array. This function will
 *  | attempt to evaluate the entire list, so should only be used on
 *  | finite inputs.
 *  | 
 *  | Running time: `O(n)` where `n` is the number of elements in the list.
 */
var toArray = function (_740) {
    if (_740 instanceof Nil) {
        return [  ];
    };
    if (_740 instanceof Cons) {
        return Prelude[":"](_740.value0)(toArray(Data_Lazy.force(_740.value1)));
    };
    throw new Error("Failed pattern match");
};

/**
 *  | Take the specified number of elements from the start of a lazy list, creating a new
 *  | lazy list.
 */
var take = function (_741) {
    return function (_742) {
        if (_741 < 1) {
            return Nil.value;
        };
        if (_742 instanceof Nil) {
            return Nil.value;
        };
        if (_742 instanceof Cons) {
            return new Cons(_742.value0, Data_Lazy.defer(function (_737) {
                return take(_741 - 1)(Data_Lazy.force(_742.value1));
            }));
        };
        throw new Error("Failed pattern match");
    };
};
var showList = function (__dict_Show_0) {
    return new Prelude.Show(function (l) {
        return "List(" + (showItems(Data_Array.map(Prelude.show(__dict_Show_0))(toArray(l))) + ")");
    });
};
var semigroupList = new Prelude.Semigroup(function (xs) {
    return function (ys) {
        return $less$dot$greater(xs)(Data_Lazy.defer(function (_733) {
            return ys;
        }));
    };
});

/**
 *  | Create an infinite lazy list which repeats the same value indefinitely.
 */
var repeat = function (x) {
    return new Cons(x, Data_Lazy.defer(function (_736) {
        return repeat(x);
    }));
};
var monoidList = new Data_Monoid.Monoid(function () {
    return semigroupList;
}, Nil.value);
var functorList = new Prelude.Functor(function (_747) {
    return function (_748) {
        if (_748 instanceof Nil) {
            return Nil.value;
        };
        if (_748 instanceof Cons) {
            return new Cons(_747(_748.value0), Prelude["<$>"](Data_Lazy.functorLazy)(Prelude["<$>"](functorList)(_747))(_748.value1));
        };
        throw new Error("Failed pattern match");
    };
});

/**
 *  | Create a lazy list from an immutable array.
 *  | 
 *  | Running time: `O(n)` where `n` is the number of elements in the array.
 */
var fromArray = Data_Foldable.foldr(Data_Foldable.foldableArray)(function (x) {
    return function (xs) {
        return new Cons(x, Data_Lazy.defer(function (_735) {
            return xs;
        }));
    };
})(Nil.value);
var eqList = function (__dict_Eq_1) {
    return new Prelude.Eq(function (l) {
        return function (l$prime) {
            return !Prelude["=="](eqList(__dict_Eq_1))(l)(l$prime);
        };
    }, function (_745) {
        return function (_746) {
            if (_745 instanceof Nil && _746 instanceof Nil) {
                return true;
            };
            if (_745 instanceof Cons && _746 instanceof Cons) {
                return Prelude["=="](__dict_Eq_1)(_745.value0)(_746.value0) && Prelude["=="](eqList(__dict_Eq_1))(Data_Lazy.force(_745.value1))(Data_Lazy.force(_746.value1));
            };
            return false;
        };
    });
};

/**
 *  | Drop the specified number of elements from the start of a lazy list, creating a new
 *  | lazy list.
 */
var drop = function (__copy__743) {
    return function (__copy__744) {
        var _743 = __copy__743;
        var _744 = __copy__744;
        tco: while (true) {
            if (_743 < 1) {
                return _744;
            };
            if (_744 instanceof Nil) {
                return Nil.value;
            };
            if (_744 instanceof Cons) {
                var __tco__743 = _743 - 1;
                var __tco__744 = Data_Lazy.force(_744.value1);
                _743 = __tco__743;
                _744 = __tco__744;
                continue tco;
            };
            throw new Error("Failed pattern match");
        };
    };
};
var monadList = new Prelude.Monad(function () {
    return applicativeList;
}, function () {
    return bindList;
});
var bindList = new Prelude.Bind(function (_749) {
    return function (_750) {
        if (_749 instanceof Nil) {
            return Nil.value;
        };
        if (_749 instanceof Cons) {
            return $less$dot$greater(_750(_749.value0))(Prelude["<$>"](Data_Lazy.functorLazy)(function (xs$prime) {
                return Prelude[">>="](bindList)(xs$prime)(_750);
            })(_749.value1));
        };
        throw new Error("Failed pattern match");
    };
}, function () {
    return applyList;
});
var applyList = new Prelude.Apply(Prelude.ap(monadList), function () {
    return functorList;
});
var applicativeList = new Prelude.Applicative(function () {
    return applyList;
}, function (x) {
    return new Cons(x, Data_Lazy.defer(function (_734) {
        return Nil.value;
    }));
});
module.exports = {
    Nil: Nil, 
    Cons: Cons, 
    drop: drop, 
    take: take, 
    repeat: repeat, 
    fromArray: fromArray, 
    toArray: toArray, 
    eqList: eqList, 
    showList: showList, 
    semigroupList: semigroupList, 
    monoidList: monoidList, 
    functorList: functorList, 
    applyList: applyList, 
    applicativeList: applicativeList, 
    bindList: bindList, 
    monadList: monadList
};
