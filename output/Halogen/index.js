// Generated by psc-make version 0.6.8

/**
 *  | The main module of the Halogen library. It defines functions for running applications
 *  | assembled from the parts defined in the various submodules:
 *  |
 *  | - `Halogen.Signal` for responding to inputs and maintaining state
 *  | - `Halogen.HTML.*` for templating HTML documents
 *  | - `Halogen.Component` for building application components
 *  | - `Halogen.Themes.*` for rendering using common front-end libraries
 *  | - `Halogen.Mixin.*` for common additional application features
 *  |
 *  | The functionality of this library is completely described by the type signature of the `runUI`
 *  | function, which renders a `Component` to the DOM. The other modules exist to make the construction
 *  | of `Component`s as simple as possible.
 *  |
 */
"use strict";
var Halogen_Signal = require("Halogen.Signal");
var Halogen_Internal_VirtualDOM = require("Halogen.Internal.VirtualDOM");
var Halogen_Component = require("Halogen.Component");
var Prelude = require("Prelude");
var Control_Monad_Eff_Ref = require("Control.Monad.Eff.Ref");
var Control_Monad_Eff_Unsafe = require("Control.Monad.Eff.Unsafe");
var Halogen_HTML_Events_Monad = require("Halogen.HTML.Events.Monad");
var Debug_Trace = require("Debug.Trace");
var Control_Monad_Eff_Exception = require("Control.Monad.Eff.Exception");
var Halogen_HTML_Renderer_VirtualDOM = require("Halogen.HTML.Renderer.VirtualDOM");
var DOM = require("DOM");
var Data_DOM_Simple_Types = require("Data.DOM.Simple.Types");
var Data_Void = require("Data.Void");
var Data_Maybe = require("Data.Maybe");
var Data_Tuple = require("Data.Tuple");
var Data_Either = require("Data.Either");
var Data_Bifunctor = require("Data.Bifunctor");
var Control_Monad_Eff = require("Control.Monad.Eff");
var Halogen_HTML = require("Halogen.HTML");

/**
 *  | A signal which emits patches corresponding to successive `VTree`s.
 *  |
 *  | This function can be used to create alternative top-level handlers which use `virtual-dom`.
 */
var changes = Halogen_Signal.differencesWith(Halogen_Internal_VirtualDOM.diff);

/**
 *  | Internal function used in the implementation of `runUI`.
 */
var runUI$prime = function (ref) {
    return function (sf) {
        var widgetHandler = Prelude["<$>"](Halogen_Internal_VirtualDOM.functorWidget)(Prelude["<<<"](Prelude.semigroupoidArr)(Prelude.pure(Halogen_HTML_Events_Monad.applicativeEvent))(Data_Either.Right.create));
        var logger = function (e) {
            return Debug_Trace.trace("Uncaught error in asynchronous code: " + Control_Monad_Eff_Exception.message(e));
        };
        var driver = function (e) {
            return function __do() {
                var _58 = Control_Monad_Eff_Ref.readRef(ref)();
                return (function () {
                    if (_58 instanceof Data_Maybe.Just) {
                        var next = Halogen_Signal.runSF(_58.value0.signal)(e);
                        return function __do() {
                            var _57 = Halogen_Internal_VirtualDOM.patch(Halogen_Signal.head(next))(_58.value0.node)();
                            return Control_Monad_Eff_Ref.writeRef(ref)(new Data_Maybe.Just({
                                signal: Halogen_Signal.tail(next), 
                                node: _57
                            }))();
                        };
                    };
                    if (_58 instanceof Data_Maybe.Nothing) {
                        return Debug_Trace.trace("Error: An attempt to re-render was made during the initial render.");
                    };
                    throw new Error("Failed pattern match");
                })()();
            };
        };
        var externalDriver = function (req) {
            return driver(new Data_Either.Right(req));
        };
        var requestHandler = function (aff) {
            return Control_Monad_Eff_Unsafe.unsafeInterleaveEff(Halogen_HTML_Events_Monad.runEvent(logger)(driver)(aff));
        };
        var render = Halogen_HTML_Renderer_VirtualDOM.renderHTML(requestHandler)(widgetHandler);
        var vtrees = Prelude["<$>"](Halogen_Signal.functorSF1)(render)(sf);
        var node = Halogen_Internal_VirtualDOM.createElement(Halogen_Signal.head(vtrees));
        var diffs = Prelude[">>>"](Halogen_Signal.semigroupoidSF)(Halogen_Signal.tail(vtrees))(changes(Halogen_Signal.head(vtrees)));
        return function __do() {
            Control_Monad_Eff_Ref.writeRef(ref)(new Data_Maybe.Just({
                signal: diffs, 
                node: node
            }))();
            return new Data_Tuple.Tuple(node, externalDriver);
        };
    };
};

/**
 *  | `runUI` renders a `Component` to the DOM using `virtual-dom`.
 *  |
 *  | This function is the workhorse of the Halogen library. It can be called in `main`
 *  | to set up the application and create the driver function, which can be used to 
 *  | send inputs to the UI from external components.
 */
var runUI = Halogen_Component.runComponent(function (sf) {
    return function __do() {
        var _56 = Control_Monad_Eff_Ref.newRef(Data_Maybe.Nothing.value)();
        return runUI$prime(_56)(sf)();
    };
});
module.exports = {
    runUI: runUI, 
    changes: changes
};
