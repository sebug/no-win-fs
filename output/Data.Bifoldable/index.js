// Generated by psc-make version 0.6.8
"use strict";
var Prelude = require("Prelude");
var Control_Apply = require("Control.Apply");
var Data_Monoid_Any = require("Data.Monoid.Any");
var Data_Monoid_All = require("Data.Monoid.All");
var Data_Const = require("Data.Const");
var Data_Either = require("Data.Either");
var Data_Monoid = require("Data.Monoid");
var Data_Tuple = require("Data.Tuple");
var Control_Bind = require("Control.Bind");

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be 
 *  | folded.
 *  | 
 *  | A fold for such a structure requires two step functions, one for each type 
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  | 
 */
var Bifoldable = function (bifoldMap, bifoldl, bifoldr) {
    this.bifoldMap = bifoldMap;
    this.bifoldl = bifoldl;
    this.bifoldr = bifoldr;
};

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be 
 *  | folded.
 *  | 
 *  | A fold for such a structure requires two step functions, one for each type 
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  | 
 */
var bifoldr = function (dict) {
    return dict.bifoldr;
};

/**
 *  | Traverse a data structure, accumulating effects using an `Applicative` functor,
 *  | ignoring the final result.
 */
var bitraverse_ = function (__dict_Bifoldable_0) {
    return function (__dict_Applicative_1) {
        return function (f) {
            return function (g) {
                return bifoldr(__dict_Bifoldable_0)(Prelude["<<<"](Prelude.semigroupoidArr)(Control_Apply["*>"](__dict_Applicative_1["__superclass_Prelude.Apply_0"]()))(f))(Prelude["<<<"](Prelude.semigroupoidArr)(Control_Apply["*>"](__dict_Applicative_1["__superclass_Prelude.Apply_0"]()))(g))(Prelude.pure(__dict_Applicative_1)(Prelude.unit));
            };
        };
    };
};

/**
 *  | A version of `bitraverse_` with the data structure as the first argument.
 */
var bifor_ = function (__dict_Bifoldable_2) {
    return function (__dict_Applicative_3) {
        return function (t) {
            return function (f) {
                return function (g) {
                    return bitraverse_(__dict_Bifoldable_2)(__dict_Applicative_3)(f)(g)(t);
                };
            };
        };
    };
};

/**
 *  | Collapse a data structure, collecting effects using an `Applicative` functor,
 *  | ignoring the final result.
 */
var bisequence_ = function (__dict_Bifoldable_4) {
    return function (__dict_Applicative_5) {
        return bitraverse_(__dict_Bifoldable_4)(__dict_Applicative_5)(Prelude.id(Prelude.categoryArr))(Prelude.id(Prelude.categoryArr));
    };
};

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be 
 *  | folded.
 *  | 
 *  | A fold for such a structure requires two step functions, one for each type 
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  | 
 */
var bifoldl = function (dict) {
    return dict.bifoldl;
};
var bifoldableTuple = new Bifoldable(function (__dict_Monoid_6) {
    return function (_577) {
        return function (_578) {
            return function (_579) {
                return Prelude["<>"](__dict_Monoid_6["__superclass_Prelude.Semigroup_0"]())(_577(_579.value0))(_578(_579.value1));
            };
        };
    };
}, function (_584) {
    return function (_585) {
        return function (_586) {
            return function (_587) {
                return _585(_584(_586)(_587.value0))(_587.value1);
            };
        };
    };
}, function (_580) {
    return function (_581) {
        return function (_582) {
            return function (_583) {
                return _580(_583.value0)(_581(_583.value1)(_582));
            };
        };
    };
});
var bifoldableEither = new Bifoldable(function (__dict_Monoid_7) {
    return function (_588) {
        return function (_589) {
            return function (_590) {
                if (_590 instanceof Data_Either.Left) {
                    return _588(_590.value0);
                };
                if (_590 instanceof Data_Either.Right) {
                    return _589(_590.value0);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
}, function (_595) {
    return function (_596) {
        return function (_597) {
            return function (_598) {
                if (_598 instanceof Data_Either.Left) {
                    return _595(_597)(_598.value0);
                };
                if (_598 instanceof Data_Either.Right) {
                    return _596(_597)(_598.value0);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
}, function (_591) {
    return function (_592) {
        return function (_593) {
            return function (_594) {
                if (_594 instanceof Data_Either.Left) {
                    return _591(_594.value0)(_593);
                };
                if (_594 instanceof Data_Either.Right) {
                    return _592(_594.value0)(_593);
                };
                throw new Error("Failed pattern match");
            };
        };
    };
});
var bifoldableConst = new Bifoldable(function (__dict_Monoid_8) {
    return function (_599) {
        return function (_600) {
            return function (_601) {
                return _599(_601);
            };
        };
    };
}, function (_606) {
    return function (_607) {
        return function (_608) {
            return function (_609) {
                return _606(_608)(_609);
            };
        };
    };
}, function (_602) {
    return function (_603) {
        return function (_604) {
            return function (_605) {
                return _602(_605)(_604);
            };
        };
    };
});

/**
 *  | `Bifoldable` represents data structures with two type arguments which can be 
 *  | folded.
 *  | 
 *  | A fold for such a structure requires two step functions, one for each type 
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  | 
 */
var bifoldMap = function (dict) {
    return dict.bifoldMap;
};

/**
 *  | Fold a data structure, accumulating values in a monoidal type.
 */
var bifold = function (__dict_Bifoldable_9) {
    return function (__dict_Monoid_10) {
        return bifoldMap(__dict_Bifoldable_9)(__dict_Monoid_10)(Prelude.id(Prelude.categoryArr))(Prelude.id(Prelude.categoryArr));
    };
};

/**
 *  | Test whether a predicate holds at any position in a data structure.
 */
var biany = function (__dict_Bifoldable_11) {
    return function (p) {
        return function (q) {
            return Prelude["<<<"](Prelude.semigroupoidArr)(Data_Monoid_Any.runAny)(bifoldMap(__dict_Bifoldable_11)(Data_Monoid_Any.monoidAny)(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Monoid_Any.Any)(p))(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Monoid_Any.Any)(q)));
        };
    };
};

/**
 *  | Test whether a predicate holds at all positions in a data structure.
 */
var biall = function (__dict_Bifoldable_12) {
    return function (p) {
        return function (q) {
            return Prelude["<<<"](Prelude.semigroupoidArr)(Data_Monoid_All.runAll)(bifoldMap(__dict_Bifoldable_12)(Data_Monoid_All.monoidAll)(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Monoid_All.All)(p))(Prelude["<<<"](Prelude.semigroupoidArr)(Data_Monoid_All.All)(q)));
        };
    };
};
module.exports = {
    Bifoldable: Bifoldable, 
    biall: biall, 
    biany: biany, 
    bisequence_: bisequence_, 
    bifor_: bifor_, 
    bitraverse_: bitraverse_, 
    bifold: bifold, 
    bifoldMap: bifoldMap, 
    bifoldl: bifoldl, 
    bifoldr: bifoldr, 
    bifoldableTuple: bifoldableTuple, 
    bifoldableEither: bifoldableEither, 
    bifoldableConst: bifoldableConst
};
