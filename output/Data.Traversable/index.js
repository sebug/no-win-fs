// Generated by psc-make version 0.6.8
"use strict";
var Prelude = require("Prelude");
var Data_Array = require("Data.Array");
var Data_Tuple = require("Data.Tuple");
var Data_Either = require("Data.Either");
var Data_Foldable = require("Data.Foldable");
var Data_Maybe = require("Data.Maybe");
var Data_Monoid_Additive = require("Data.Monoid.Additive");
var Data_Monoid_Dual = require("Data.Monoid.Dual");
var Data_Monoid_First = require("Data.Monoid.First");
var Data_Monoid_Last = require("Data.Monoid.Last");
var Data_Monoid_Multiplicative = require("Data.Monoid.Multiplicative");
var StateR = function (x) {
    return x;
};
var StateL = function (x) {
    return x;
};

/**
 *  | `Traversable` represents data structures which can be _traversed_,
 *  | accumulating results and effects in some `Applicative` functor.
 *  |
 *  | - `traverse` runs an action for every element in a data structure,
 *  |   and accumulates the results.
 *  | - `sequence` runs the actions _contained_ in a data structure,
 *  |   and accumulates the results.
 *  |
 *  | The `traverse` and `sequence` functions should be compatible in the
 *  | following sense:
 *  |
 *  | - `traverse f xs = sequence (f <$> xs)`
 *  | - `sequence = traverse id` 
 *  | 
 *  | `Traversable` instances should also be compatible with the corresponding
 *  | `Foldable` instances, in the following sense:
 *  |
 *  | - `foldMap f = runConst <<< traverse (Const <<< f)`
 */
var Traversable = function (__superclass_Data$dotFoldable$dotFoldable_1, __superclass_Prelude$dotFunctor_0, sequence, traverse) {
    this["__superclass_Data.Foldable.Foldable_1"] = __superclass_Data$dotFoldable$dotFoldable_1;
    this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    this.sequence = sequence;
    this.traverse = traverse;
};

/**
 *  | `Traversable` represents data structures which can be _traversed_,
 *  | accumulating results and effects in some `Applicative` functor.
 *  |
 *  | - `traverse` runs an action for every element in a data structure,
 *  |   and accumulates the results.
 *  | - `sequence` runs the actions _contained_ in a data structure,
 *  |   and accumulates the results.
 *  |
 *  | The `traverse` and `sequence` functions should be compatible in the
 *  | following sense:
 *  |
 *  | - `traverse f xs = sequence (f <$> xs)`
 *  | - `sequence = traverse id` 
 *  | 
 *  | `Traversable` instances should also be compatible with the corresponding
 *  | `Foldable` instances, in the following sense:
 *  |
 *  | - `foldMap f = runConst <<< traverse (Const <<< f)`
 */
var traverse = function (dict) {
    return dict.traverse;
};
var traversableTuple = new Traversable(function () {
    return Data_Foldable.foldableTuple;
}, function () {
    return Data_Tuple.functorTuple;
}, function (__dict_Applicative_1) {
    return function (_531) {
        return Prelude["<$>"]((__dict_Applicative_1["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Tuple.Tuple.create(_531.value0))(_531.value1);
    };
}, function (__dict_Applicative_0) {
    return function (_529) {
        return function (_530) {
            return Prelude["<$>"]((__dict_Applicative_0["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Tuple.Tuple.create(_530.value0))(_529(_530.value1));
        };
    };
});
var traversableMultiplicative = new Traversable(function () {
    return Data_Foldable.foldableMultiplicative;
}, function () {
    return Data_Monoid_Multiplicative.functorMultiplicative;
}, function (__dict_Applicative_3) {
    return function (_546) {
        return Prelude["<$>"]((__dict_Applicative_3["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Multiplicative.Multiplicative)(_546);
    };
}, function (__dict_Applicative_2) {
    return function (_544) {
        return function (_545) {
            return Prelude["<$>"]((__dict_Applicative_2["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Multiplicative.Multiplicative)(_544(_545));
        };
    };
});
var traversableMaybe = new Traversable(function () {
    return Data_Foldable.foldableMaybe;
}, function () {
    return Data_Maybe.functorMaybe;
}, function (__dict_Applicative_5) {
    return function (_528) {
        if (_528 instanceof Data_Maybe.Nothing) {
            return Prelude.pure(__dict_Applicative_5)(Data_Maybe.Nothing.value);
        };
        if (_528 instanceof Data_Maybe.Just) {
            return Prelude["<$>"]((__dict_Applicative_5["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Maybe.Just.create)(_528.value0);
        };
        throw new Error("Failed pattern match");
    };
}, function (__dict_Applicative_4) {
    return function (_526) {
        return function (_527) {
            if (_527 instanceof Data_Maybe.Nothing) {
                return Prelude.pure(__dict_Applicative_4)(Data_Maybe.Nothing.value);
            };
            if (_527 instanceof Data_Maybe.Just) {
                return Prelude["<$>"]((__dict_Applicative_4["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Maybe.Just.create)(_526(_527.value0));
            };
            throw new Error("Failed pattern match");
        };
    };
});
var traversableEither = new Traversable(function () {
    return Data_Foldable.foldableEither;
}, function () {
    return Data_Either.functorEither;
}, function (__dict_Applicative_7) {
    return function (_525) {
        if (_525 instanceof Data_Either.Left) {
            return Prelude.pure(__dict_Applicative_7)(new Data_Either.Left(_525.value0));
        };
        if (_525 instanceof Data_Either.Right) {
            return Prelude["<$>"]((__dict_Applicative_7["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Either.Right.create)(_525.value0);
        };
        throw new Error("Failed pattern match");
    };
}, function (__dict_Applicative_6) {
    return function (_523) {
        return function (_524) {
            if (_524 instanceof Data_Either.Left) {
                return Prelude.pure(__dict_Applicative_6)(new Data_Either.Left(_524.value0));
            };
            if (_524 instanceof Data_Either.Right) {
                return Prelude["<$>"]((__dict_Applicative_6["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Either.Right.create)(_523(_524.value0));
            };
            throw new Error("Failed pattern match");
        };
    };
});
var traversableDual = new Traversable(function () {
    return Data_Foldable.foldableDual;
}, function () {
    return Data_Monoid_Dual.functorDual;
}, function (__dict_Applicative_9) {
    return function (_537) {
        return Prelude["<$>"]((__dict_Applicative_9["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Dual.Dual)(_537);
    };
}, function (__dict_Applicative_8) {
    return function (_535) {
        return function (_536) {
            return Prelude["<$>"]((__dict_Applicative_8["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Dual.Dual)(_535(_536));
        };
    };
});
var traversableAdditive = new Traversable(function () {
    return Data_Foldable.foldableAdditive;
}, function () {
    return Data_Monoid_Additive.functorAdditive;
}, function (__dict_Applicative_11) {
    return function (_534) {
        return Prelude["<$>"]((__dict_Applicative_11["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Additive.Additive)(_534);
    };
}, function (__dict_Applicative_10) {
    return function (_532) {
        return function (_533) {
            return Prelude["<$>"]((__dict_Applicative_10["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Additive.Additive)(_532(_533));
        };
    };
});
var stateR = function (_519) {
    return _519;
};
var stateL = function (_518) {
    return _518;
};

/**
 *  | `Traversable` represents data structures which can be _traversed_,
 *  | accumulating results and effects in some `Applicative` functor.
 *  |
 *  | - `traverse` runs an action for every element in a data structure,
 *  |   and accumulates the results.
 *  | - `sequence` runs the actions _contained_ in a data structure,
 *  |   and accumulates the results.
 *  |
 *  | The `traverse` and `sequence` functions should be compatible in the
 *  | following sense:
 *  |
 *  | - `traverse f xs = sequence (f <$> xs)`
 *  | - `sequence = traverse id` 
 *  | 
 *  | `Traversable` instances should also be compatible with the corresponding
 *  | `Foldable` instances, in the following sense:
 *  |
 *  | - `foldMap f = runConst <<< traverse (Const <<< f)`
 */
var sequence = function (dict) {
    return dict.sequence;
};
var traversableArray = new Traversable(function () {
    return Data_Foldable.foldableArray;
}, function () {
    return Data_Array.functorArray;
}, function (__dict_Applicative_13) {
    return function (_522) {
        if (_522.length === 0) {
            return Prelude.pure(__dict_Applicative_13)([  ]);
        };
        if (_522.length >= 1) {
            var _1915 = _522.slice(1);
            return Prelude["<*>"](__dict_Applicative_13["__superclass_Prelude.Apply_0"]())(Prelude["<$>"]((__dict_Applicative_13["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Prelude[":"])(_522[0]))(sequence(traversableArray)(__dict_Applicative_13)(_1915));
        };
        throw new Error("Failed pattern match");
    };
}, function (__dict_Applicative_12) {
    return function (_520) {
        return function (_521) {
            if (_521.length === 0) {
                return Prelude.pure(__dict_Applicative_12)([  ]);
            };
            if (_521.length >= 1) {
                var _1919 = _521.slice(1);
                return Prelude["<*>"](__dict_Applicative_12["__superclass_Prelude.Apply_0"]())(Prelude["<$>"]((__dict_Applicative_12["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Prelude[":"])(_520(_521[0])))(traverse(traversableArray)(__dict_Applicative_12)(_520)(_1919));
            };
            throw new Error("Failed pattern match");
        };
    };
});
var traversableFirst = new Traversable(function () {
    return Data_Foldable.foldableFirst;
}, function () {
    return Data_Monoid_First.functorFirst;
}, function (__dict_Applicative_15) {
    return function (_540) {
        return Prelude["<$>"]((__dict_Applicative_15["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_First.First)(sequence(traversableMaybe)(__dict_Applicative_15)(_540));
    };
}, function (__dict_Applicative_14) {
    return function (_538) {
        return function (_539) {
            return Prelude["<$>"]((__dict_Applicative_14["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_First.First)(traverse(traversableMaybe)(__dict_Applicative_14)(_538)(_539));
        };
    };
});
var traversableLast = new Traversable(function () {
    return Data_Foldable.foldableLast;
}, function () {
    return Data_Monoid_Last.functorLast;
}, function (__dict_Applicative_17) {
    return function (_543) {
        return Prelude["<$>"]((__dict_Applicative_17["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Last.Last)(sequence(traversableMaybe)(__dict_Applicative_17)(_543));
    };
}, function (__dict_Applicative_16) {
    return function (_541) {
        return function (_542) {
            return Prelude["<$>"]((__dict_Applicative_16["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Monoid_Last.Last)(traverse(traversableMaybe)(__dict_Applicative_16)(_541)(_542));
        };
    };
});

/**
 *  | A generalization of `zipWith` which accumulates results in some `Applicative`
 *  | functor.
 */
var zipWithA = function (__dict_Applicative_18) {
    return function (f) {
        return function (xs) {
            return function (ys) {
                return sequence(traversableArray)(__dict_Applicative_18)(Data_Array.zipWith(f)(xs)(ys));
            };
        };
    };
};
var functorStateR = new Prelude.Functor(function (f) {
    return function (k) {
        return StateR(function (s) {
            var _1926 = stateR(k)(s);
            return new Data_Tuple.Tuple(_1926.value0, f(_1926.value1));
        });
    };
});
var functorStateL = new Prelude.Functor(function (f) {
    return function (k) {
        return StateL(function (s) {
            var _1929 = stateL(k)(s);
            return new Data_Tuple.Tuple(_1929.value0, f(_1929.value1));
        });
    };
});

/**
 *  | A version of `traverse` with its arguments flipped.
 *  |
 *  | 
 *  | This can be useful when running an action written using do notation
 *  | for every element in a data structure:
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | for [1, 2, 3] \n -> do
 *  |   print n
 *  |   return (n * n)
 *  | ```
 */
var $$for = function (__dict_Applicative_23) {
    return function (__dict_Traversable_24) {
        return function (x) {
            return function (f) {
                return traverse(__dict_Traversable_24)(__dict_Applicative_23)(f)(x);
            };
        };
    };
};
var applyStateR = new Prelude.Apply(function (f) {
    return function (x) {
        return StateR(function (s) {
            var _1932 = stateR(x)(s);
            var _1933 = stateR(f)(_1932.value0);
            return new Data_Tuple.Tuple(_1933.value0, _1933.value1(_1932.value1));
        });
    };
}, function () {
    return functorStateR;
});
var applyStateL = new Prelude.Apply(function (f) {
    return function (x) {
        return StateL(function (s) {
            var _1938 = stateL(f)(s);
            var _1939 = stateL(x)(_1938.value0);
            return new Data_Tuple.Tuple(_1939.value0, _1938.value1(_1939.value1));
        });
    };
}, function () {
    return functorStateL;
});
var applicativeStateR = new Prelude.Applicative(function () {
    return applyStateR;
}, function (a) {
    return StateR(function (s) {
        return new Data_Tuple.Tuple(s, a);
    });
});

/**
 *  | Fold a data structure from the right, keeping all intermediate results
 *  | instead of only the final result.
 *  |
 *  | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ
 *  | from the element type of the final data structure.
 */
var mapAccumR = function (__dict_Traversable_19) {
    return function (f) {
        return function (s0) {
            return function (xs) {
                return stateR(traverse(__dict_Traversable_19)(applicativeStateR)(function (a) {
                    return StateR(function (s) {
                        return f(s)(a);
                    });
                })(xs))(s0);
            };
        };
    };
};

/**
 *  | Fold a data structure from the right, keeping all intermediate results
 *  | instead of only the final result.
 */
var scanr = function (__dict_Traversable_20) {
    return function (f) {
        return function (b0) {
            return function (xs) {
                return Data_Tuple.snd(mapAccumR(__dict_Traversable_20)(function (b) {
                    return function (a) {
                        var b$prime = f(a)(b);
                        return new Data_Tuple.Tuple(b$prime, b$prime);
                    };
                })(b0)(xs));
            };
        };
    };
};
var applicativeStateL = new Prelude.Applicative(function () {
    return applyStateL;
}, function (a) {
    return StateL(function (s) {
        return new Data_Tuple.Tuple(s, a);
    });
});

/**
 *  | Fold a data structure from the left, keeping all intermediate results
 *  | instead of only the final result.
 *  |
 *  | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ
 *  | from the element type of the final data structure.
 */
var mapAccumL = function (__dict_Traversable_21) {
    return function (f) {
        return function (s0) {
            return function (xs) {
                return stateL(traverse(__dict_Traversable_21)(applicativeStateL)(function (a) {
                    return StateL(function (s) {
                        return f(s)(a);
                    });
                })(xs))(s0);
            };
        };
    };
};

/**
 *  | Fold a data structure from the left, keeping all intermediate results
 *  | instead of only the final result.
 */
var scanl = function (__dict_Traversable_22) {
    return function (f) {
        return function (b0) {
            return function (xs) {
                return Data_Tuple.snd(mapAccumL(__dict_Traversable_22)(function (b) {
                    return function (a) {
                        var b$prime = f(b)(a);
                        return new Data_Tuple.Tuple(b$prime, b$prime);
                    };
                })(b0)(xs));
            };
        };
    };
};
module.exports = {
    Traversable: Traversable, 
    mapAccumR: mapAccumR, 
    mapAccumL: mapAccumL, 
    scanr: scanr, 
    scanl: scanl, 
    zipWithA: zipWithA, 
    "for": $$for, 
    sequence: sequence, 
    traverse: traverse, 
    traversableArray: traversableArray, 
    traversableEither: traversableEither, 
    traversableMaybe: traversableMaybe, 
    traversableTuple: traversableTuple, 
    traversableAdditive: traversableAdditive, 
    traversableDual: traversableDual, 
    traversableFirst: traversableFirst, 
    traversableLast: traversableLast, 
    traversableMultiplicative: traversableMultiplicative
};
