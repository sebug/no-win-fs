// Generated by psc-make version 0.6.8

/**
 *  | A low-level primitive for building asynchronous code.
 */
"use strict";
var Control_Monad_Aff = require("Control.Monad.Aff");
var Prelude = require("Prelude");
var Data_Function = require("Data.Function");
var Control_Monad_Eff_Exception = require("Control.Monad.Eff.Exception");

    function _makeVar(nonCanceler) {
      return function(success, error) {
        try {
          success({
            consumers: [],
            producers: [],
            error: undefined 
          });
        } catch (e) {
          error(e);
        }

        return nonCanceler;
      }
    }
  ;

    function _takeVar(nonCanceler, avar) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else if (avar.producers.length > 0) {
          var producer = avar.producers.shift();

          producer(success, error);
        } else {
          avar.consumers.push({success: success, error: error});
        }

        return nonCanceler;
      } 
    }
  ;

    function _putVar(nonCanceler, avar, a) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else if (avar.consumers.length === 0) {
          avar.producers.push(function(success, error) {
            try {
              success(a);
            } catch (e) {
              error(e);
            }
          });

          success({});
        } else {
          var consumer = avar.consumers.shift();

          try {
            consumer.success(a);
          } catch (e) {
            error(e);

            return;                  
          }

          success({});
        }

        return nonCanceler;
      }
    }
  ;

    function _killVar(nonCanceler, avar, e) {
      return function(success, error) {
        if (avar.error !== undefined) {
          error(avar.error);
        } else {
          var errors = [];

          avar.error = e;

          while (avar.consumers.length > 0) {
            var consumer = avar.consumers.shift();

            try {
              consumer.error(e);
            } catch (e) {
              errors.push(e);              
            }
          }

          if (errors.length > 0) error(errors[0]);
          else success({});
        }

        return nonCanceler;
      }
    }
  ;

/**
 *  | Takes the next value from the asynchronous avar.
 */
var takeVar = function (q) {
    return _takeVar(Control_Monad_Aff.nonCanceler, q);
};

/**
 *  | Puts a new value into the asynchronous avar. If the avar has
 *  | been killed, this will result in an error.
 */
var putVar = function (q) {
    return function (a) {
        return _putVar(Control_Monad_Aff.nonCanceler, q, a);
    };
};

/**
 *  | Modifies the value at the head of the avar (will suspend until one is available).
 */
var modifyVar = function (f) {
    return function (v) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(takeVar(v))(Prelude[">>>"](Prelude.semigroupoidArr)(f)(putVar(v)));
    };
};

/**
 *  | Makes a new asynchronous avar.
 */
var makeVar = _makeVar(Control_Monad_Aff.nonCanceler);

/**
 *  | Makes a avar and sets it to some value.
 */
var makeVar$prime = function (a) {
    return Prelude[">>="](Control_Monad_Aff.bindAff)(makeVar)(function (_27) {
        return Prelude[">>="](Control_Monad_Aff.bindAff)(putVar(_27)(a))(function () {
            return Prelude["return"](Control_Monad_Aff.monadAff)(_27);
        });
    });
};

/**
 *  | Kills an asynchronous avar.
 */
var killVar = function (q) {
    return function (e) {
        return _killVar(Control_Monad_Aff.nonCanceler, q, e);
    };
};
module.exports = {
    takeVar: takeVar, 
    putVar: putVar, 
    modifyVar: modifyVar, 
    "makeVar'": makeVar$prime, 
    makeVar: makeVar, 
    killVar: killVar
};
