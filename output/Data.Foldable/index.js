// Generated by psc-make version 0.6.8
"use strict";
var Prelude = require("Prelude");
var Data_Monoid = require("Data.Monoid");
var Control_Apply = require("Control.Apply");
var Data_Monoid_First = require("Data.Monoid.First");
var Data_Either = require("Data.Either");
var Data_Maybe = require("Data.Maybe");
var Data_Monoid_Additive = require("Data.Monoid.Additive");
var Data_Monoid_Dual = require("Data.Monoid.Dual");
var Data_Monoid_Last = require("Data.Monoid.Last");
var Data_Monoid_Multiplicative = require("Data.Monoid.Multiplicative");
var Data_Tuple = require("Data.Tuple");

  function foldrArray(f) {
    return function(z) {
      return function(xs) {
        var acc = z;
        for (var i = xs.length - 1; i >= 0; --i) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  }
  ;

  function foldlArray(f) {
    return function(z) {
      return function(xs) {
        var acc = z;
        for (var i = 0, len = xs.length; i < len; ++i) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  }
  ;

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 */
var Foldable = function (foldMap, foldl, foldr) {
    this.foldMap = foldMap;
    this.foldl = foldl;
    this.foldr = foldr;
};

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 */
var foldr = function (dict) {
    return dict.foldr;
};

/**
 *  | Traverse a data structure, performing some effects encoded by an
 *  | `Applicative` functor at each value, ignoring the final result.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | traverse_ print [1, 2, 3]
 *  | ```
 */
var traverse_ = function (__dict_Applicative_0) {
    return function (__dict_Foldable_1) {
        return function (f) {
            return foldr(__dict_Foldable_1)(Prelude["<<<"](Prelude.semigroupoidArr)(Control_Apply["*>"](__dict_Applicative_0["__superclass_Prelude.Apply_0"]()))(f))(Prelude.pure(__dict_Applicative_0)(Prelude.unit));
        };
    };
};

/**
 *  | A version of `traverse_` with its arguments flipped.
 *  |
 *  | This can be useful when running an action written using do notation
 *  | for every element in a data structure:
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | for_ [1, 2, 3] \n -> do
 *  |   print n
 *  |   trace "squared is"
 *  |   print (n * n)
 *  | ```
 */
var for_ = function (__dict_Applicative_2) {
    return function (__dict_Foldable_3) {
        return Prelude.flip(traverse_(__dict_Applicative_2)(__dict_Foldable_3));
    };
};

/**
 *  | Perform all of the effects in some data structure in the order
 *  | given by the `Foldable` instance, ignoring the final result.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | sequence_ [ trace "Hello, ", trace " world!" ]
 *  | ```
 */
var sequence_ = function (__dict_Applicative_4) {
    return function (__dict_Foldable_5) {
        return traverse_(__dict_Applicative_4)(__dict_Foldable_5)(Prelude.id(Prelude.categoryArr));
    };
};

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 */
var foldl = function (dict) {
    return dict.foldl;
};

/**
 *  | Fold a data structure, accumulating values in some `Monoid`,
 *  | combining adjacent elements using the specified separator. 
 */
var intercalate = function (__dict_Foldable_6) {
    return function (__dict_Monoid_7) {
        return function (sep) {
            return function (xs) {
                var go = function (_498) {
                    return function (_499) {
                        if (_498.init) {
                            return {
                                init: false, 
                                acc: _499
                            };
                        };
                        return {
                            init: false, 
                            acc: Prelude["<>"](__dict_Monoid_7["__superclass_Prelude.Semigroup_0"]())(_498.acc)(Prelude["<>"](__dict_Monoid_7["__superclass_Prelude.Semigroup_0"]())(sep)(_499))
                        };
                    };
                };
                return (foldl(__dict_Foldable_6)(go)({
                    init: true, 
                    acc: Data_Monoid.mempty(__dict_Monoid_7)
                })(xs)).acc;
            };
        };
    };
};

/**
 *  | Fold a data structure, accumulating values in some `Monoid`.
 */
var mconcat = function (__dict_Foldable_8) {
    return function (__dict_Monoid_9) {
        return foldl(__dict_Foldable_8)(Prelude["<>"](__dict_Monoid_9["__superclass_Prelude.Semigroup_0"]()))(Data_Monoid.mempty(__dict_Monoid_9));
    };
};

/**
 *  | Test whether any `Boolean` value in a data structure is `true`.
 */
var or = function (__dict_Foldable_10) {
    return foldl(__dict_Foldable_10)(Prelude["||"](Prelude.boolLikeBoolean))(false);
};

/**
 *  | Find the product of the numeric values in a data structure.
 */
var product = function (__dict_Foldable_11) {
    return foldl(__dict_Foldable_11)(Prelude["*"](Prelude.semiringNumber))(1);
};

/**
 *  | Find the sum of the numeric values in a data structure.
 */
var sum = function (__dict_Foldable_12) {
    return foldl(__dict_Foldable_12)(Prelude["+"](Prelude.semiringNumber))(0);
};
var foldableTuple = new Foldable(function (__dict_Monoid_13) {
    return function (_456) {
        return function (_457) {
            return _456(_457.value1);
        };
    };
}, function (_453) {
    return function (_454) {
        return function (_455) {
            return _453(_454)(_455.value1);
        };
    };
}, function (_450) {
    return function (_451) {
        return function (_452) {
            return _450(_452.value1)(_451);
        };
    };
});
var foldableMultiplicative = new Foldable(function (__dict_Monoid_14) {
    return function (_496) {
        return function (_497) {
            return _496(_497);
        };
    };
}, function (_493) {
    return function (_494) {
        return function (_495) {
            return _493(_494)(_495);
        };
    };
}, function (_490) {
    return function (_491) {
        return function (_492) {
            return _490(_492)(_491);
        };
    };
});
var foldableMaybe = new Foldable(function (__dict_Monoid_15) {
    return function (_448) {
        return function (_449) {
            if (_449 instanceof Data_Maybe.Nothing) {
                return Data_Monoid.mempty(__dict_Monoid_15);
            };
            if (_449 instanceof Data_Maybe.Just) {
                return _448(_449.value0);
            };
            throw new Error("Failed pattern match");
        };
    };
}, function (_445) {
    return function (_446) {
        return function (_447) {
            if (_447 instanceof Data_Maybe.Nothing) {
                return _446;
            };
            if (_447 instanceof Data_Maybe.Just) {
                return _445(_446)(_447.value0);
            };
            throw new Error("Failed pattern match");
        };
    };
}, function (_442) {
    return function (_443) {
        return function (_444) {
            if (_444 instanceof Data_Maybe.Nothing) {
                return _443;
            };
            if (_444 instanceof Data_Maybe.Just) {
                return _442(_444.value0)(_443);
            };
            throw new Error("Failed pattern match");
        };
    };
});
var foldableEither = new Foldable(function (__dict_Monoid_16) {
    return function (_440) {
        return function (_441) {
            if (_441 instanceof Data_Either.Left) {
                return Data_Monoid.mempty(__dict_Monoid_16);
            };
            if (_441 instanceof Data_Either.Right) {
                return _440(_441.value0);
            };
            throw new Error("Failed pattern match");
        };
    };
}, function (_437) {
    return function (_438) {
        return function (_439) {
            if (_439 instanceof Data_Either.Left) {
                return _438;
            };
            if (_439 instanceof Data_Either.Right) {
                return _437(_438)(_439.value0);
            };
            throw new Error("Failed pattern match");
        };
    };
}, function (_434) {
    return function (_435) {
        return function (_436) {
            if (_436 instanceof Data_Either.Left) {
                return _435;
            };
            if (_436 instanceof Data_Either.Right) {
                return _434(_436.value0)(_435);
            };
            throw new Error("Failed pattern match");
        };
    };
});
var foldableDual = new Foldable(function (__dict_Monoid_17) {
    return function (_472) {
        return function (_473) {
            return _472(_473);
        };
    };
}, function (_469) {
    return function (_470) {
        return function (_471) {
            return _469(_470)(_471);
        };
    };
}, function (_466) {
    return function (_467) {
        return function (_468) {
            return _466(_468)(_467);
        };
    };
});
var foldableArray = new Foldable(function (__dict_Monoid_18) {
    return function (f) {
        return function (xs) {
            return foldr(foldableArray)(function (x) {
                return function (acc) {
                    return Prelude["<>"](__dict_Monoid_18["__superclass_Prelude.Semigroup_0"]())(f(x))(acc);
                };
            })(Data_Monoid.mempty(__dict_Monoid_18))(xs);
        };
    };
}, function (f) {
    return function (z) {
        return function (xs) {
            return foldlArray(f)(z)(xs);
        };
    };
}, function (f) {
    return function (z) {
        return function (xs) {
            return foldrArray(f)(z)(xs);
        };
    };
});
var foldableAdditive = new Foldable(function (__dict_Monoid_19) {
    return function (_464) {
        return function (_465) {
            return _464(_465);
        };
    };
}, function (_461) {
    return function (_462) {
        return function (_463) {
            return _461(_462)(_463);
        };
    };
}, function (_458) {
    return function (_459) {
        return function (_460) {
            return _458(_460)(_459);
        };
    };
});

/**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 */
var foldMap = function (dict) {
    return dict.foldMap;
};
var foldableFirst = new Foldable(function (__dict_Monoid_20) {
    return function (_480) {
        return function (_481) {
            return foldMap(foldableMaybe)(__dict_Monoid_20)(_480)(_481);
        };
    };
}, function (_477) {
    return function (_478) {
        return function (_479) {
            return foldl(foldableMaybe)(_477)(_478)(_479);
        };
    };
}, function (_474) {
    return function (_475) {
        return function (_476) {
            return foldr(foldableMaybe)(_474)(_475)(_476);
        };
    };
});
var foldableLast = new Foldable(function (__dict_Monoid_21) {
    return function (_488) {
        return function (_489) {
            return foldMap(foldableMaybe)(__dict_Monoid_21)(_488)(_489);
        };
    };
}, function (_485) {
    return function (_486) {
        return function (_487) {
            return foldl(foldableMaybe)(_485)(_486)(_487);
        };
    };
}, function (_482) {
    return function (_483) {
        return function (_484) {
            return foldr(foldableMaybe)(_482)(_483)(_484);
        };
    };
});

/**
 *  | Lookup a value in a data structure of `Tuple`s, generalizing association lists.
 */
var lookup = function (__dict_Eq_22) {
    return function (__dict_Foldable_23) {
        return function (a) {
            return function (f) {
                return Data_Monoid_First.runFirst(foldMap(__dict_Foldable_23)(Data_Monoid_First.monoidFirst)(function (_433) {
                    var _1842 = Prelude["=="](__dict_Eq_22)(a)(_433.value0);
                    if (_1842) {
                        return new Data_Maybe.Just(_433.value1);
                    };
                    if (!_1842) {
                        return Data_Maybe.Nothing.value;
                    };
                    throw new Error("Failed pattern match");
                })(f));
            };
        };
    };
};

/**
 *  | Fold a data structure, accumulating values in some `Monoid`.
 */
var fold = function (__dict_Foldable_24) {
    return function (__dict_Monoid_25) {
        return foldMap(__dict_Foldable_24)(__dict_Monoid_25)(Prelude.id(Prelude.categoryArr));
    };
};

/**
 *  | Try to find an element in a data structure which satisfies a predicate.
 */
var find = function (__dict_Foldable_26) {
    return function (p) {
        return function (f) {
            var _1846 = foldMap(__dict_Foldable_26)(Data_Monoid.monoidArray)(function (x) {
                var _1845 = p(x);
                if (_1845) {
                    return [ x ];
                };
                if (!_1845) {
                    return [  ];
                };
                throw new Error("Failed pattern match");
            })(f);
            if (_1846.length >= 1) {
                var _1848 = _1846.slice(1);
                return new Data_Maybe.Just(_1846[0]);
            };
            if (_1846.length === 0) {
                return Data_Maybe.Nothing.value;
            };
            throw new Error("Failed pattern match");
        };
    };
};

/**
 *  | Test whether a predicate holds for any element in a data structure.
 */
var any = function (__dict_Foldable_27) {
    return function (p) {
        return Prelude["<<<"](Prelude.semigroupoidArr)(or(foldableArray))(foldMap(__dict_Foldable_27)(Data_Monoid.monoidArray)(function (x) {
            return [ p(x) ];
        }));
    };
};

/**
 *  | Test whether a value is an element of a data structure.
 */
var elem = function (__dict_Eq_28) {
    return function (__dict_Foldable_29) {
        return Prelude["<<<"](Prelude.semigroupoidArr)(any(__dict_Foldable_29))(Prelude["=="](__dict_Eq_28));
    };
};

/**
 *  | Test whether a value is not an element of a data structure.
 */
var notElem = function (__dict_Eq_30) {
    return function (__dict_Foldable_31) {
        return function (x) {
            return Prelude["<<<"](Prelude.semigroupoidArr)(Prelude.not(Prelude.boolLikeBoolean))(elem(__dict_Eq_30)(__dict_Foldable_31)(x));
        };
    };
};

/**
 *  | Test whether all `Boolean` values in a data structure are `true`.
 */
var and = function (__dict_Foldable_32) {
    return foldl(__dict_Foldable_32)(Prelude["&&"](Prelude.boolLikeBoolean))(true);
};

/**
 *  | Test whether a predicate holds for all elements in a data structure.
 */
var all = function (__dict_Foldable_33) {
    return function (p) {
        return Prelude["<<<"](Prelude.semigroupoidArr)(and(foldableArray))(foldMap(__dict_Foldable_33)(Data_Monoid.monoidArray)(function (x) {
            return [ p(x) ];
        }));
    };
};
module.exports = {
    Foldable: Foldable, 
    foldlArray: foldlArray, 
    foldrArray: foldrArray, 
    lookup: lookup, 
    find: find, 
    notElem: notElem, 
    elem: elem, 
    product: product, 
    sum: sum, 
    all: all, 
    any: any, 
    or: or, 
    and: and, 
    intercalate: intercalate, 
    mconcat: mconcat, 
    sequence_: sequence_, 
    for_: for_, 
    traverse_: traverse_, 
    fold: fold, 
    foldMap: foldMap, 
    foldl: foldl, 
    foldr: foldr, 
    foldableArray: foldableArray, 
    foldableEither: foldableEither, 
    foldableMaybe: foldableMaybe, 
    foldableTuple: foldableTuple, 
    foldableAdditive: foldableAdditive, 
    foldableDual: foldableDual, 
    foldableFirst: foldableFirst, 
    foldableLast: foldableLast, 
    foldableMultiplicative: foldableMultiplicative
};
