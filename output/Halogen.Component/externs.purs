-- Generated by psc-make version 0.6.8
module Halogen.Component where
import Data.Either ()
import Data.Void ()
import Prelude ()
import Halogen.Component ()
import Data.Profunctor ()
import Data.Bifunctor ()
import Data.Exists ()
import Halogen.HTML.Widget ()
import Halogen.Signal ()
import Halogen.HTML ()
import Data.Maybe ()
import Prim ()
import Prelude ()
import Data.DOM.Simple.Types ()
import Data.Int ()
import Data.Maybe ()
import Data.Void ()
import Data.Either ()
import Data.Exists ()
import Data.Bifunctor ()
import Data.Profunctor ()
import Control.Monad.Eff ()
import Halogen.HTML ()
import Halogen.Signal ()
import Halogen.Internal.VirtualDOM ()
import Halogen.HTML.Widget ()
--  | This will be hidden inside the existential package `Component`.
--  | A component.
--  | 
--  | The type parameters are, in order:
--  |
--  | - `p`, the type of _placeholders_
--  | - `m`, the monad used to track effects required by external requests
--  | - `req`, the type of external requests
--  | - `res`, the type of external responses
--  | 
--  | Request and response types are public, but the component may also use an _internal_ type
--  | of messages, as illustrated by the type of the `component` function.
--  |
--  | The main interface to Halogen is the `runUI` function, which takes a component as an argument,
--  | with certain constraints between the type arguments. This module leaves the type arguments
--  | unrestricted, allowing components to be composed in various ways.
--  |
--  | If you do not use a particular feature (e.g. placeholders, requests), you might like to leave 
--  | the corresponding type parameter unconstrained in the declaration of your component. 
--  | Unpack a component.
--  |
--  | The rank-2 type ensures that the hidden message type must be used abstractly.
--  | A variant of `component` which creates a component with some internal, hidden input type.
--  | Hide some of the internal messages in a `Component`.
--  | Map a natural transformation over the monad type argument of a `Component`.
--  |
--  | This function may be useful during testing, to mock requests with a different monad.
--  | Map a function over the placeholders in a component          
--  | Create a component by providing a signal function.
--  |
--  | The signal function should consume external requests and produce DOM nodes. The DOM
--  | nodes in turn will create (monadic) external requests.
--  |
--  | See the `Halogen.Signal` documentation.
--  | Construct a `Component` from a third-party widget.
--  |
--  | The function argument is a record with the following properties:
--  |
--  | - `name` - the type of the widget, required by `virtual-dom` to distinguish different
--  |   types of widget.
--  | - `id` - a unique ID which belongs to this instance of the widget type, required by 
--  |   `virtual-dom` to distinguish widgets from each other.
--  | - `init` - an action which initializes the component and returns the `HTMLElement` it corresponds
--  |   to in the DOM. This action receives the driver function for the component so that it can
--  |   generate events. It can also create a piece of state of type `s` which is shared with the
--  |   other lifecycle functions.
--  | - `update` - Update the widget based on an input message.
--  | - `destroy` - Release any resources associated with the widget as it is about to be removed
--  |   from the DOM.
--  | Combine two components into a single component.
--  |
--  | The first argument is a function which combines the two rendered HTML documents into a single document.
--  |
--  | This function works on request and response types by taking the _sum_ in each component. The left summand
--  | gets dispatched to (resp. is generated by) the first component, and the right summand to the second component.
--  | Install a component inside another, by replacing a placeholder.
--  |
--  | The placeholders labelled with `Nothing` in the second component will be replaced with the
--  | first component. Placeholders labelled with `Just` will remain as placeholders.
data Component (p :: *) (m :: * -> *) (req :: *) (res :: *)
foreign import hoistComponent :: forall p m n req res. (forall a. m a -> n a) -> Halogen.Component.Component p m req res -> Halogen.Component.Component p n req res
foreign import mapP :: forall p q m req res. (p -> q) -> Halogen.Component.Component p m req res -> Halogen.Component.Component q m req res
foreign import widget :: forall eff req res ctx m. (Prelude.Functor m) => { destroy :: ctx -> Data.DOM.Simple.Types.HTMLElement -> Control.Monad.Eff.Eff eff Prelude.Unit, update :: req -> ctx -> Data.DOM.Simple.Types.HTMLElement -> Control.Monad.Eff.Eff eff (Data.Maybe.Maybe Data.DOM.Simple.Types.HTMLElement), init :: (res -> Control.Monad.Eff.Eff eff Prelude.Unit) -> Control.Monad.Eff.Eff eff { node :: Data.DOM.Simple.Types.HTMLElement, context :: ctx }, id :: Prim.String, name :: Prim.String } -> Halogen.Component.Component (Halogen.Internal.VirtualDOM.Widget eff res) m req res
foreign import hide :: forall p m i req res. (Prelude.Functor m) => Halogen.Component.Component p m (Data.Either.Either i req) (Data.Either.Either i res) -> Halogen.Component.Component p m req res
foreign import combine :: forall p q r m req1 req2 res1 res2. (Prelude.Functor m) => (forall a. Halogen.HTML.HTML p a -> Halogen.HTML.HTML q a -> Halogen.HTML.HTML r a) -> Halogen.Component.Component p m req1 res1 -> Halogen.Component.Component q m req2 res2 -> Halogen.Component.Component r m (Data.Either.Either req1 req2) (Data.Either.Either res1 res2)
foreign import install :: forall p m req1 req2 res1 res2. (Prelude.Functor m) => Halogen.Component.Component p m req1 res1 -> Halogen.Component.Component (Data.Maybe.Maybe p) m req2 res2 -> Halogen.Component.Component p m (Data.Either.Either req1 req2) (Data.Either.Either res1 res2)
foreign import component' :: forall p m req res i. Halogen.Signal.SF1 (Data.Either.Either i req) (Halogen.HTML.HTML p (m (Data.Either.Either i res))) -> Halogen.Component.Component p m req res
foreign import component :: forall p m req res. (Prelude.Functor m) => Halogen.Signal.SF1 req (Halogen.HTML.HTML p (m res)) -> Halogen.Component.Component p m req res
foreign import runComponent :: forall p m req res r. (forall i. Halogen.Signal.SF1 (Data.Either.Either i req) (Halogen.HTML.HTML p (m (Data.Either.Either i res))) -> r) -> Halogen.Component.Component p m req res -> r
foreign import instance functorComponent :: (Prelude.Functor m) => Prelude.Functor (Halogen.Component.Component p m req)
foreign import instance profunctorComponent :: (Prelude.Functor m) => Data.Profunctor.Profunctor (Halogen.Component.Component p m)
