// Generated by psc-make version 0.6.8

/**
 *  | This module defines a type of composable _components_.
 */
"use strict";
var Data_Either = require("Data.Either");
var Data_Void = require("Data.Void");
var Prelude = require("Prelude");
var Data_Profunctor = require("Data.Profunctor");
var Data_Bifunctor = require("Data.Bifunctor");
var Data_Exists = require("Data.Exists");
var Halogen_HTML_Widget = require("Halogen.HTML.Widget");
var Halogen_Signal = require("Halogen.Signal");
var Halogen_HTML = require("Halogen.HTML");
var Data_Maybe = require("Data.Maybe");
var Data_DOM_Simple_Types = require("Data.DOM.Simple.Types");
var Data_Int = require("Data.Int");
var Control_Monad_Eff = require("Control.Monad.Eff");
var Halogen_Internal_VirtualDOM = require("Halogen.Internal.VirtualDOM");

/**
 *  | This will be hidden inside the existential package `Component`.
 */
var ComponentF = function (x) {
    return x;
};

/**
 *  | A component.
 *  | 
 *  | The type parameters are, in order:
 *  |
 *  | - `p`, the type of _placeholders_
 *  | - `m`, the monad used to track effects required by external requests
 *  | - `req`, the type of external requests
 *  | - `res`, the type of external responses
 *  | 
 *  | Request and response types are public, but the component may also use an _internal_ type
 *  | of messages, as illustrated by the type of the `component` function.
 *  |
 *  | The main interface to Halogen is the `runUI` function, which takes a component as an argument,
 *  | with certain constraints between the type arguments. This module leaves the type arguments
 *  | unrestricted, allowing components to be composed in various ways.
 *  |
 *  | If you do not use a particular feature (e.g. placeholders, requests), you might like to leave 
 *  | the corresponding type parameter unconstrained in the declaration of your component. 
 */
var Component = function (x) {
    return x;
};

/**
 *  | Unpack a component.
 *  |
 *  | The rank-2 type ensures that the hidden message type must be used abstractly.
 */
var runComponent = function (_967) {
    return function (_968) {
        return Data_Exists.runExists(function (_966) {
            return _967(_966);
        })(_968);
    };
};

/**
 *  | A variant of `component` which creates a component with some internal, hidden input type.
 */
var component$prime = function (sf) {
    return Data_Exists.mkExists(sf);
};

/**
 *  | Hide some of the internal messages in a `Component`.
 */
var hide = function (__dict_Functor_1) {
    var g = function (_972) {
        if (_972 instanceof Data_Either.Left && _972.value0 instanceof Data_Either.Left) {
            return new Data_Either.Left(_972.value0.value0);
        };
        if (_972 instanceof Data_Either.Left && _972.value0 instanceof Data_Either.Right) {
            return new Data_Either.Right(new Data_Either.Left(_972.value0.value0));
        };
        if (_972 instanceof Data_Either.Right) {
            return new Data_Either.Right(new Data_Either.Right(_972.value0));
        };
        throw new Error("Failed pattern match");
    };
    var f = function (_971) {
        if (_971 instanceof Data_Either.Left) {
            return new Data_Either.Left(new Data_Either.Left(_971.value0));
        };
        if (_971 instanceof Data_Either.Right && _971.value0 instanceof Data_Either.Left) {
            return new Data_Either.Left(new Data_Either.Right(_971.value0.value0));
        };
        if (_971 instanceof Data_Either.Right && _971.value0 instanceof Data_Either.Right) {
            return new Data_Either.Right(_971.value0.value0);
        };
        throw new Error("Failed pattern match");
    };
    return runComponent(function (sf1) {
        return component$prime(Data_Profunctor.dimap(Halogen_Signal.profunctorSF1)(g)(Prelude["<$>"](Halogen_HTML.functorHTML)(Prelude["<$>"](__dict_Functor_1)(f)))(sf1));
    });
};

/**
 *  | Map a natural transformation over the monad type argument of a `Component`.
 *  |
 *  | This function may be useful during testing, to mock requests with a different monad.
 */
var hoistComponent = function (f) {
    return runComponent(function (sf) {
        return component$prime(Prelude["<$>"](Halogen_Signal.functorSF1)(Data_Bifunctor.rmap(Halogen_HTML.bifunctorHTML)(f))(sf));
    });
};

/**
 *  | Map a function over the placeholders in a component          
 */
var mapP = function (f) {
    return runComponent(function (sf) {
        return component$prime(Prelude["<$>"](Halogen_Signal.functorSF1)(Data_Bifunctor.lmap(Halogen_HTML.bifunctorHTML)(f))(sf));
    });
};
var profunctorComponent = function (__dict_Functor_2) {
    return new Data_Profunctor.Profunctor(function (f) {
        return function (g) {
            return runComponent(function (sf) {
                return component$prime(Data_Profunctor.dimap(Halogen_Signal.profunctorSF1)(Prelude["<$>"](Data_Either.functorEither)(f))(Data_Bifunctor.rmap(Halogen_HTML.bifunctorHTML)(Prelude["<$>"](__dict_Functor_2)(Prelude["<$>"](Data_Either.functorEither)(g))))(sf));
            });
        };
    });
};
var functorComponent = function (__dict_Functor_0) {
    return new Prelude.Functor(Data_Profunctor.rmap(profunctorComponent(__dict_Functor_0)));
};

/**
 *  | Create a component by providing a signal function.
 *  |
 *  | The signal function should consume external requests and produce DOM nodes. The DOM
 *  | nodes in turn will create (monadic) external requests.
 *  |
 *  | See the `Halogen.Signal` documentation.
 */
var component = function (__dict_Functor_3) {
    return function (sf) {
        var f = Data_Either.either(Data_Void.absurd)(Prelude.id(Prelude.categoryArr));
        return component$prime(Data_Profunctor.dimap(Halogen_Signal.profunctorSF1)(f)(Data_Bifunctor.rmap(Halogen_HTML.bifunctorHTML)(Prelude["<$>"](__dict_Functor_3)(Data_Either.Right.create)))(sf));
    };
};

/**
 *  | Construct a `Component` from a third-party widget.
 *  |
 *  | The function argument is a record with the following properties:
 *  |
 *  | - `name` - the type of the widget, required by `virtual-dom` to distinguish different
 *  |   types of widget.
 *  | - `id` - a unique ID which belongs to this instance of the widget type, required by 
 *  |   `virtual-dom` to distinguish widgets from each other.
 *  | - `init` - an action which initializes the component and returns the `HTMLElement` it corresponds
 *  |   to in the DOM. This action receives the driver function for the component so that it can
 *  |   generate events. It can also create a piece of state of type `s` which is shared with the
 *  |   other lifecycle functions.
 *  | - `update` - Update the widget based on an input message.
 *  | - `destroy` - Release any resources associated with the widget as it is about to be removed
 *  |   from the DOM.
 */
var widget = function (__dict_Functor_4) {
    return function (spec) {
        var version = Halogen_Signal.tail(Halogen_Signal.stateful(Prelude.zero(Data_Int.semiringInt))(function (i) {
            return function (_965) {
                return Prelude["+"](Data_Int.semiringInt)(i)(Prelude.one(Data_Int.semiringInt));
            };
        }));
        var buildWidget = function (ver) {
            return function (update) {
                return Halogen_HTML_Widget.widget({
                    value: ver, 
                    name: spec.name, 
                    id: spec.id, 
                    init: spec.init, 
                    update: update, 
                    destroy: spec.destroy
                });
            };
        };
        var updateWith = function (i) {
            return function (n) {
                var updateIfVersionChanged = function (_969) {
                    return function (_970) {
                        if (Prelude[">"](Data_Int.ordInt)(_969)(_970)) {
                            return spec.update(i);
                        };
                        if (Prelude.otherwise) {
                            return function (_964) {
                                return function (_963) {
                                    return Prelude["return"](Control_Monad_Eff.monadEff)(Data_Maybe.Nothing.value);
                                };
                            };
                        };
                        throw new Error("Failed pattern match");
                    };
                };
                return buildWidget(n)(updateIfVersionChanged);
            };
        };
        var w0 = buildWidget(Prelude.zero(Data_Int.semiringInt))(function (_962) {
            return function (_961) {
                return function (_960) {
                    return function (_959) {
                        return Prelude["return"](Control_Monad_Eff.monadEff)(Data_Maybe.Nothing.value);
                    };
                };
            };
        });
        return component(__dict_Functor_4)(Prelude["<$>"](Halogen_Signal.functorSF1)(Halogen_HTML.placeholder)(Halogen_Signal.startingAt(Prelude["<*>"](Halogen_Signal.applySF)(Prelude["<$>"](Halogen_Signal.functorSF)(updateWith)(Halogen_Signal.input))(version))(w0)));
    };
};

/**
 *  | Combine two components into a single component.
 *  |
 *  | The first argument is a function which combines the two rendered HTML documents into a single document.
 *  |
 *  | This function works on request and response types by taking the _sum_ in each component. The left summand
 *  | gets dispatched to (resp. is generated by) the first component, and the right summand to the second component.
 */
var combine = function (__dict_Functor_5) {
    return function (f) {
        var f3 = function (_974) {
            if (_974 instanceof Data_Either.Left && _974.value0 instanceof Data_Either.Left) {
                return new Data_Either.Left(new Data_Either.Left(_974.value0.value0));
            };
            if (_974 instanceof Data_Either.Right && _974.value0 instanceof Data_Either.Left) {
                return new Data_Either.Left(new Data_Either.Right(_974.value0.value0));
            };
            if (_974 instanceof Data_Either.Left && _974.value0 instanceof Data_Either.Right) {
                return new Data_Either.Right(new Data_Either.Left(_974.value0.value0));
            };
            if (_974 instanceof Data_Either.Right && _974.value0 instanceof Data_Either.Right) {
                return new Data_Either.Right(new Data_Either.Right(_974.value0.value0));
            };
            throw new Error("Failed pattern match");
        };
        var f2 = function (n1) {
            return function (n2) {
                return Data_Bifunctor.rmap(Halogen_HTML.bifunctorHTML)(Prelude["<$>"](__dict_Functor_5)(f3))(f(Data_Bifunctor.rmap(Halogen_HTML.bifunctorHTML)(Prelude["<$>"](__dict_Functor_5)(Data_Either.Left.create))(n1))(Data_Bifunctor.rmap(Halogen_HTML.bifunctorHTML)(Prelude["<$>"](__dict_Functor_5)(Data_Either.Right.create))(n2)));
            };
        };
        var f1 = function (_973) {
            if (_973 instanceof Data_Either.Left && _973.value0 instanceof Data_Either.Left) {
                return new Data_Either.Left(new Data_Either.Left(_973.value0.value0));
            };
            if (_973 instanceof Data_Either.Left && _973.value0 instanceof Data_Either.Right) {
                return new Data_Either.Right(new Data_Either.Left(_973.value0.value0));
            };
            if (_973 instanceof Data_Either.Right && _973.value0 instanceof Data_Either.Left) {
                return new Data_Either.Left(new Data_Either.Right(_973.value0.value0));
            };
            if (_973 instanceof Data_Either.Right && _973.value0 instanceof Data_Either.Right) {
                return new Data_Either.Right(new Data_Either.Right(_973.value0.value0));
            };
            throw new Error("Failed pattern match");
        };
        return runComponent(function (sf1) {
            return runComponent(function (sf2) {
                return component$prime(Halogen_Signal["mergeWith'"](f1)(f2)(sf1)(sf2));
            });
        });
    };
};

/**
 *  | Install a component inside another, by replacing a placeholder.
 *  |
 *  | The placeholders labelled with `Nothing` in the second component will be replaced with the
 *  | first component. Placeholders labelled with `Just` will remain as placeholders.
 */
var install = function (__dict_Functor_6) {
    var render = function (doc1) {
        return function (doc2) {
            return Halogen_HTML.graft(doc2)(Data_Maybe.maybe(doc1)(Halogen_HTML.placeholder));
        };
    };
    return combine(__dict_Functor_6)(render);
};
module.exports = {
    hoistComponent: hoistComponent, 
    mapP: mapP, 
    widget: widget, 
    hide: hide, 
    combine: combine, 
    install: install, 
    "component'": component$prime, 
    component: component, 
    runComponent: runComponent, 
    functorComponent: functorComponent, 
    profunctorComponent: profunctorComponent
};
