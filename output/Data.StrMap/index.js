// Generated by psc-make version 0.6.8

/**
 *  | This module defines a type of native Javascript maps which 
 *  | require the keys to be strings.
 *  | 
 *  | To maximize performance, Javascript objects are not wrapped,
 *  | and some native code is used even when it's not necessary.
 */
"use strict";
var Control_Monad_Eff = require("Control.Monad.Eff");
var Prelude = require("Prelude");
var Data_Function = require("Data.Function");
var Data_Monoid = require("Data.Monoid");
var Data_Foldable = require("Data.Foldable");
var Data_Tuple = require("Data.Tuple");
var Data_Traversable = require("Data.Traversable");
var Data_Maybe = require("Data.Maybe");
var Data_StrMap_ST = require("Data.StrMap.ST");
var Data_Monoid_All = require("Data.Monoid.All");
var Control_Monad_ST = require("Control.Monad.ST");
var Data_Array = require("Data.Array");

  function _copy(m) {
    var r = {};
    for (var k in m) {
      r[k] = m[k];
    }
    return r;
  }
  ;

  function _copyEff(m) {
    return function() {
      var r = {};
      for (var k in m) {
        r[k] = m[k];
      }
      return r;
    };
  }
  ;

  function runST(f) {
    return f;
  }
  ;

  function _fmapStrMap(m0, f) {
    var m = {};
    for (var k in m0) {
      m[k] = f(m0[k]);
    }
    return m;
  }
  ;

  function _foldM(bind) {
    return function(f) {
      return function(mz) {
        return function(m) {
          function g(k) {
            return function (z) {
              return f(z)(k)(m[k]);
            };
          }
          for (var k in m) {
            mz = bind(mz)(g(k));
          }
          return mz;
        };
      };
    };
  }
  ;

  function _foldSCStrMap(m, z, f, fromMaybe) {
    for (var k in m) {
      var maybeR = f(z)(k)(m[k]);
      var r = fromMaybe(null)(maybeR);
      if (r === null) return z;
      else z = r;
    }
    return z;
  }
  ;

  function all(f) {
    return function(m) {
      for (var k in m) {
        if (!f(k)(m[k])) return false;
      }
      return true;
    };
  }
  ;
var empty = {};;

  function size(m) {
    var s = 0;
    for (var k in m) {
      ++s;
    }
    return s;
  }
  ;

  function _lookup(no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  }
  ;

  function _unsafeDeleteStrMap(m, k) {
     delete m[k];
     return m;
  }
  ;

  function _lookupST(no, yes, k, m) {
    return function() {
      return k in m ? yes(m[k]) : no;
    }
  }
  ;

  function _collect(f) {
    return function(m) {
      var r = [];
      for (var k in m) {
        r.push(f(k)(m[k]));
      }
      return r;
    };
  }
  ;

  var keys = Object.keys || _collect(function(k) {
    return function() { return k; };
  });
  ;

/**
 *  | Get an array of the values in a map
 */
var values = _collect(function (_803) {
    return function (v) {
        return v;
    };
});

/**
 *  | Convert a map into an array of key/value pairs
 */
var toList = _collect(Data_Tuple.Tuple.create);

/**
 *  | Convert an immutable map into a mutable map
 */
var thawST = _copyEff;
var showStrMap = function (__dict_Show_0) {
    return new Prelude.Show(function (m) {
        return "fromList " + Prelude.show(Prelude.showArray(Data_Tuple.showTuple(Prelude.showString)(__dict_Show_0)))(toList(m));
    });
};
var pureST = function (f) {
    return Control_Monad_Eff.runPure(runST(f));
};

/**
 *  | Create a map with one key/value pair
 */
var singleton = function (k) {
    return function (v) {
        return pureST(function __do() {
            var _44 = Data_StrMap_ST["new"]();
            Data_StrMap_ST.poke(_44)(k)(v)();
            return _44;
        });
    };
};
var mutate = function (f) {
    return function (m) {
        return pureST(function __do() {
            var _43 = thawST(m)();
            f(_43)();
            return _43;
        });
    };
};

/**
 *  | Test whether a `String` appears as a key in a map
 */
var member = Data_Function.runFn4(_lookup)(false)(Prelude["const"](true));

/**
 *  | Lookup the value for a key in a map
 */
var lookup = Data_Function.runFn4(_lookup)(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);

/**
 *  | Test whether one map contains all of the keys and values contained in another map
 */
var isSubmap = function (__dict_Eq_2) {
    return function (m1) {
        return function (m2) {
            var f = function (k) {
                return function (v) {
                    return _lookup(false, Prelude["=="](__dict_Eq_2)(v), k, m2);
                };
            };
            return all(f)(m1);
        };
    };
};

/**
 *  | Test whether a map is empty
 */
var isEmpty = all(function (_800) {
    return function (_799) {
        return false;
    };
});

/**
 *  | Insert a key and value into a map
 */
var insert = function (k) {
    return function (v) {
        return mutate(function (s) {
            return Data_StrMap_ST.poke(s)(k)(v);
        });
    };
};
var functorStrMap = new Prelude.Functor(function (f) {
    return function (m) {
        return _fmapStrMap(m, f);
    };
});

/**
 *  | Map a function over the values in a map
 */
var map = Prelude["<$>"](functorStrMap);

/**
 *  | Create a map from an array of key/value pairs, using the specified function
 *  | to combine values for duplicate keys.
 */
var fromListWith = function (f) {
    return function (l) {
        return pureST(function __do() {
            var _46 = Data_StrMap_ST["new"]();
            Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(Data_Foldable.foldableArray)(l)(function (_802) {
                return Prelude[">>="](Control_Monad_Eff.bindEff)(_lookupST(_802.value1, f(_802.value1), _802.value0, _46))(Data_StrMap_ST.poke(_46)(_802.value0));
            })();
            return _46;
        });
    };
};

/**
 *  | Create a map from an array of key/value pairs
 */
var fromList = function (l) {
    return pureST(function __do() {
        var _45 = Data_StrMap_ST["new"]();
        Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(Data_Foldable.foldableArray)(l)(function (_801) {
            return Data_StrMap_ST.poke(_45)(_801.value0)(_801.value1);
        })();
        return _45;
    });
};

/**
 *  | Convert a mutable map into an immutable map
 */
var freezeST = _copyEff;

/**
 *  | Fold the keys and values of a map.
 *  |
 *  | This function allows the folding function to terminate the fold early,
 *  | using `Maybe`.
 */
var foldMaybe = function (f) {
    return function (z) {
        return function (m) {
            return _foldSCStrMap(m, z, f, Data_Maybe.fromMaybe);
        };
    };
};

/**
 *  | Fold the keys and values of a map, accumulating values and effects in
 *  | some `Monad`.
 */
var foldM = function (__dict_Monad_3) {
    return function (f) {
        return function (z) {
            return _foldM(Prelude[">>="](__dict_Monad_3["__superclass_Prelude.Bind_1"]()))(f)(Prelude.pure(__dict_Monad_3["__superclass_Prelude.Applicative_0"]())(z));
        };
    };
};
var semigroupStrMap = function (__dict_Semigroup_4) {
    return new Prelude.Semigroup(function (m1) {
        return function (m2) {
            return mutate(function (s) {
                return foldM(Control_Monad_Eff.monadEff)(function (s_1) {
                    return function (k) {
                        return function (v2) {
                            return Data_StrMap_ST.poke(s_1)(k)(_lookup(v2, function (v1) {
                                return Prelude["<>"](__dict_Semigroup_4)(v1)(v2);
                            }, k, m2));
                        };
                    };
                })(s)(m1);
            })(m2);
        };
    });
};
var monoidStrMap = function (__dict_Semigroup_1) {
    return new Data_Monoid.Monoid(function () {
        return semigroupStrMap(__dict_Semigroup_1);
    }, empty);
};

/**
 *  | Compute the union of two maps, preferring the first map in the case of 
 *  | duplicate keys.
 */
var union = function (m) {
    return mutate(function (s) {
        return foldM(Control_Monad_Eff.monadEff)(Data_StrMap_ST.poke)(s)(m);
    });
};

/**
 *  | Compute the union of a collection of maps
 */
var unions = Data_Foldable.foldl(Data_Foldable.foldableArray)(union)(empty);

/**
 *  | Fold the keys and values of a map
 */
var fold = _foldM(Prelude["#"]);

/**
 *  | Fold the keys and values of a map, accumulating values using
 *  | some `Monoid`.
 */
var foldMap = function (__dict_Monoid_7) {
    return function (f) {
        return fold(function (acc) {
            return function (k) {
                return function (v) {
                    return Prelude["<>"](__dict_Monoid_7["__superclass_Prelude.Semigroup_0"]())(acc)(f(k)(v));
                };
            };
        })(Data_Monoid.mempty(__dict_Monoid_7));
    };
};
var foldableStrMap = new Data_Foldable.Foldable(function (__dict_Monoid_8) {
    return function (f) {
        return foldMap(__dict_Monoid_8)(Prelude["const"](f));
    };
}, function (f) {
    return fold(function (z) {
        return function (_798) {
            return f(z);
        };
    });
}, function (f) {
    return function (z) {
        return function (m) {
            return Data_Foldable.foldr(Data_Foldable.foldableArray)(f)(z)(values(m));
        };
    };
});
var traversableStrMap = new Data_Traversable.Traversable(function () {
    return foldableStrMap;
}, function () {
    return functorStrMap;
}, function (__dict_Applicative_6) {
    return Data_Traversable.traverse(traversableStrMap)(__dict_Applicative_6)(Prelude.id(Prelude.categoryArr));
}, function (__dict_Applicative_5) {
    return function (f) {
        return function (ms) {
            return Data_Foldable.foldr(Data_Foldable.foldableArray)(function (x) {
                return function (acc) {
                    return Prelude["<*>"](__dict_Applicative_5["__superclass_Prelude.Apply_0"]())(Prelude["<$>"]((__dict_Applicative_5["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(union)(x))(acc);
                };
            })(Prelude.pure(__dict_Applicative_5)(empty))(Prelude["<$>"](Data_Array.functorArray)(Prelude["<$>"]((__dict_Applicative_5["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Data_Tuple.uncurry(singleton)))(Prelude["<$>"](Data_Array.functorArray)(Data_Traversable.traverse(Data_Traversable.traversableTuple)(__dict_Applicative_5)(f))(toList(ms))));
        };
    };
});
var eqStrMap = function (__dict_Eq_9) {
    return new Prelude.Eq(function (m1) {
        return function (m2) {
            return !Prelude["=="](eqStrMap(__dict_Eq_9))(m1)(m2);
        };
    }, function (m1) {
        return function (m2) {
            return isSubmap(__dict_Eq_9)(m1)(m2) && isSubmap(__dict_Eq_9)(m2)(m1);
        };
    });
};

/**
 *  | Delete a key and value from a map
 */
var $$delete = function (k) {
    return mutate(function (s) {
        return Data_StrMap_ST["delete"](s)(k);
    });
};

/**
 *  | Insert, remove or update a value for a key in a map
 */
var alter = function (f) {
    return function (k) {
        return function (m) {
            var _2839 = f(lookup(k)(m));
            if (_2839 instanceof Data_Maybe.Nothing) {
                return $$delete(k)(m);
            };
            if (_2839 instanceof Data_Maybe.Just) {
                return insert(k)(_2839.value0)(m);
            };
            throw new Error("Failed pattern match");
        };
    };
};

/**
 *  | Remove or update a value for a key in a map
 */
var update = function (f) {
    return function (k) {
        return function (m) {
            return alter(Data_Maybe.maybe(Data_Maybe.Nothing.value)(f))(k)(m);
        };
    };
};
module.exports = {
    runST: runST, 
    freezeST: freezeST, 
    thawST: thawST, 
    all: all, 
    foldMaybe: foldMaybe, 
    foldM: foldM, 
    foldMap: foldMap, 
    fold: fold, 
    isSubmap: isSubmap, 
    map: map, 
    unions: unions, 
    union: union, 
    values: values, 
    keys: keys, 
    update: update, 
    alter: alter, 
    member: member, 
    "delete": $$delete, 
    fromListWith: fromListWith, 
    fromList: fromList, 
    toList: toList, 
    lookup: lookup, 
    insert: insert, 
    singleton: singleton, 
    size: size, 
    isEmpty: isEmpty, 
    empty: empty, 
    functorStrMap: functorStrMap, 
    foldableStrMap: foldableStrMap, 
    traversableStrMap: traversableStrMap, 
    eqStrMap: eqStrMap, 
    showStrMap: showStrMap, 
    semigroupStrMap: semigroupStrMap, 
    monoidStrMap: monoidStrMap
};
