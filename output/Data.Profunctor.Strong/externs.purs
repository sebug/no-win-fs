-- Generated by psc-make version 0.6.8
module Data.Profunctor.Strong where
import Prelude ()
import Data.Profunctor.Strong ()
import Data.Profunctor ()
import Prim ()
import Prelude ()
import Data.Profunctor ()
import Data.Tuple ()
--  | The `Strong` class extends `Profunctor` with combinators for working with
--  | product types.
--  |
--  | `first` and `first` lift values in a `Profunctor` to act on the first and 
--  | second components of a `Tuple`, respectively.
--  |
--  | The `Strong` class extends `Profunctor` with combinators for working with
--  | product types.
--  |
--  | `first` and `first` lift values in a `Profunctor` to act on the first and 
--  | second components of a `Tuple`, respectively.
--  |
infixr 3 ***
infixr 3 &&&
--  | The `Strong` class extends `Profunctor` with combinators for working with
--  | product types.
--  |
--  | `first` and `first` lift values in a `Profunctor` to act on the first and 
--  | second components of a `Tuple`, respectively.
--  |
--  | The `Strong` class extends `Profunctor` with combinators for working with
--  | product types.
--  |
--  | `first` and `first` lift values in a `Profunctor` to act on the first and 
--  | second components of a `Tuple`, respectively.
--  |
--  | Compose a value acting on a `Tuple` from two values, each acting on one of
--  | the components of the `Tuple`.
--  | Compose a value which introduces a `Tuple` from two values, each introducing
--  | one side of the `Tuple`.
--  |
--  | This combinator is useful when assembling values from smaller components,
--  | because it provides a way to support two different types of output.
class (Data.Profunctor.Profunctor p) <= Strong p where
  first :: forall a b c. p a b -> p (Data.Tuple.Tuple a c) (Data.Tuple.Tuple b c)
  second :: forall a b c. p b c -> p (Data.Tuple.Tuple a b) (Data.Tuple.Tuple a c)
foreign import (&&&) :: forall p a b c. (Prelude.Category p, Data.Profunctor.Strong.Strong p) => p a b -> p a c -> p a (Data.Tuple.Tuple b c)
foreign import (***) :: forall p a b c d. (Prelude.Category p, Data.Profunctor.Strong.Strong p) => p a b -> p c d -> p (Data.Tuple.Tuple a c) (Data.Tuple.Tuple b d)
foreign import instance strongArr :: Data.Profunctor.Strong.Strong Prim.Function
