// Generated by psc-make version 0.6.8
"use strict";
var Prelude = require("Prelude");
var Data_Profunctor = require("Data.Profunctor");
var Data_Tuple = require("Data.Tuple");

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `first` lift values in a `Profunctor` to act on the first and 
 *  | second components of a `Tuple`, respectively.
 *  |
 */
var Strong = function (__superclass_Data$dotProfunctor$dotProfunctor_0, first, second) {
    this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
    this.first = first;
    this.second = second;
};
var strongArr = new Strong(function () {
    return Data_Profunctor.profunctorArr;
}, function (_371) {
    return function (_372) {
        return new Data_Tuple.Tuple(_371(_372.value0), _372.value1);
    };
}, Prelude["<$>"](Data_Tuple.functorTuple));

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `first` lift values in a `Profunctor` to act on the first and 
 *  | second components of a `Tuple`, respectively.
 *  |
 */
var second = function (dict) {
    return dict.second;
};

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `first` lift values in a `Profunctor` to act on the first and 
 *  | second components of a `Tuple`, respectively.
 *  |
 */
var first = function (dict) {
    return dict.first;
};

/**
 *  | Compose a value acting on a `Tuple` from two values, each acting on one of
 *  | the components of the `Tuple`.
 */
var $times$times$times = function (__dict_Category_0) {
    return function (__dict_Strong_1) {
        return function (l) {
            return function (r) {
                return Prelude[">>>"](__dict_Category_0["__superclass_Prelude.Semigroupoid_0"]())(first(__dict_Strong_1)(l))(second(__dict_Strong_1)(r));
            };
        };
    };
};

/**
 *  | Compose a value which introduces a `Tuple` from two values, each introducing
 *  | one side of the `Tuple`.
 *  |
 *  | This combinator is useful when assembling values from smaller components,
 *  | because it provides a way to support two different types of output.
 */
var $amp$amp$amp = function (__dict_Category_2) {
    return function (__dict_Strong_3) {
        return function (l) {
            return function (r) {
                var split = Data_Profunctor.dimap(__dict_Strong_3["__superclass_Data.Profunctor.Profunctor_0"]())(Prelude.id(Prelude.categoryArr))(function (a) {
                    return new Data_Tuple.Tuple(a, a);
                })(Prelude.id(__dict_Category_2));
                return Prelude[">>>"](__dict_Category_2["__superclass_Prelude.Semigroupoid_0"]())(split)($times$times$times(__dict_Category_2)(__dict_Strong_3)(l)(r));
            };
        };
    };
};
module.exports = {
    Strong: Strong, 
    "&&&": $amp$amp$amp, 
    "***": $times$times$times, 
    second: second, 
    first: first, 
    strongArr: strongArr
};
