// Generated by psc-make version 0.6.8

/**
 *  | This module defines the `Event` monad.
 */
"use strict";
var Control_Monad_Aff = require("Control.Monad.Aff");
var Control_Monad_ListT = require("Control.Monad.ListT");
var Prelude = require("Prelude");
var Control_Apply = require("Control.Apply");
var Control_Monad_Aff_Class = require("Control.Monad.Aff.Class");
var Data_Monoid = require("Data.Monoid");
var Control_Monad_Trans = require("Control.Monad.Trans");
var Control_Monad_Eff_Class = require("Control.Monad.Eff.Class");
var Control_Alt = require("Control.Alt");
var Control_Plus = require("Control.Plus");
var Data_Tuple = require("Data.Tuple");
var Data_Maybe = require("Data.Maybe");
var Control_Alternative = require("Control.Alternative");
var Control_MonadPlus = require("Control.MonadPlus");
var Control_Monad_Eff = require("Control.Monad.Eff");
var Control_Monad_Eff_Exception = require("Control.Monad.Eff.Exception");

/**
 *  | The `Event` monad, which supports the asynchronous generation of events.
 *  | 
 *  | This monad is used in the definition of `runUI`.
 */
var Event = function (x) {
    return x;
};

/**
 *  | Unwrap the `Event` constructor.
 */
var unEvent = function (_983) {
    return _983;
};
var semigroupEvent = new Prelude.Semigroup(function (_987) {
    return function (_988) {
        return Prelude["<>"](Control_Monad_ListT.semigroupListT(Control_Monad_Aff.applicativeAff))(_987)(_988);
    };
});

/**
 *  | Run a computation in the `Event` monad by providing a callback function.
 *  |
 *  | The callback function will be invoked zero or more times.
 */
var runEvent = function (f) {
    return function (s) {
        var handler = function (_986) {
            if (_986 instanceof Data_Maybe.Nothing) {
                return Prelude["return"](Control_Monad_Eff.monadEff)(Prelude.unit);
            };
            if (_986 instanceof Data_Maybe.Just) {
                return Control_Apply["*>"](Control_Monad_Eff.applyEff)(s(_986.value0.value0))(go(_986.value0.value1));
            };
            throw new Error("Failed pattern match");
        };
        var go = function (l) {
            return Control_Monad_Aff.runAff(f)(handler)(Control_Monad_Aff.later(Control_Monad_ListT.uncons(Control_Monad_Aff.monadAff)(l)));
        };
        return Prelude["<<<"](Prelude.semigroupoidArr)(go)(unEvent);
    };
};
var monoidEvent = new Data_Monoid.Monoid(function () {
    return semigroupEvent;
}, Data_Monoid.mempty(Control_Monad_ListT.monoidListT(Control_Monad_Aff.applicativeAff)));
var monadAffEvent = new Control_Monad_Aff_Class.MonadAff(Prelude["<<<"](Prelude.semigroupoidArr)(Event)(Control_Monad_Trans.lift(Control_Monad_ListT.monadTransListT)(Control_Monad_Aff.monadAff)));
var functorEvent = new Prelude.Functor(function (_989) {
    return function (_990) {
        return Prelude["<$>"](Control_Monad_ListT.functorListT(Control_Monad_Aff.functorAff))(_989)(_990);
    };
});

/**
 *  | Lift an asynchronous computation into the `Event` monad.
 */
var async = Control_Monad_Aff_Class.liftAff(monadAffEvent);

/**
 *  | Yield an event. In practice, the event will be passed to the driver function.
 */
var $$yield = Prelude["<<<"](Prelude.semigroupoidArr)(async)(Prelude.pure(Control_Monad_Aff.applicativeAff));
var applyEvent = new Prelude.Apply(function (_991) {
    return function (_992) {
        return Prelude["<*>"](Control_Monad_ListT.applyListT(Control_Monad_Aff.monadAff))(_991)(_992);
    };
}, function () {
    return functorEvent;
});
var bindEvent = new Prelude.Bind(function (_993) {
    return function (_994) {
        return Prelude[">>="](Control_Monad_ListT.bindListT(Control_Monad_Aff.monadAff))(_993)(Prelude[">>>"](Prelude.semigroupoidArr)(_994)(unEvent));
    };
}, function () {
    return applyEvent;
});
var applicativeEvent = new Prelude.Applicative(function () {
    return applyEvent;
}, Prelude["<<<"](Prelude.semigroupoidArr)(Event)(Prelude.pure(Control_Monad_ListT.applicativeListT(Control_Monad_Aff.monadAff))));
var monadEvent = new Prelude.Monad(function () {
    return applicativeEvent;
}, function () {
    return bindEvent;
});
var monadEffEvent = new Control_Monad_Eff_Class.MonadEff(function () {
    return monadEvent;
}, Prelude["<<<"](Prelude.semigroupoidArr)(Event)(Prelude["<<<"](Prelude.semigroupoidArr)(Control_Monad_Trans.lift(Control_Monad_ListT.monadTransListT)(Control_Monad_Aff.monadAff))(Control_Monad_Eff_Class.liftEff(Control_Monad_Aff.monadEffAff))));

/**
 *  | A combinator which branches based on the supplied function after the first result,
 *  | and returns to the original stream of events after the secondary stream has been
 *  | exhausted.
 */
var andThen = function (_984) {
    return function (_985) {
        var go = function (l_1) {
            return Control_Monad_ListT.wrapEffect(Control_Monad_Aff.monadAff)(Prelude[">>="](Control_Monad_Aff.bindAff)(Control_Monad_ListT.uncons(Control_Monad_Aff.monadAff)(l_1))(function (_55) {
                return Prelude["return"](Control_Monad_Aff.monadAff)((function () {
                    if (_55 instanceof Data_Maybe.Nothing) {
                        return Control_Monad_ListT.nil(Control_Monad_Aff.applicativeAff);
                    };
                    if (_55 instanceof Data_Maybe.Just) {
                        return Prelude["<>"](Control_Monad_ListT.semigroupListT(Control_Monad_Aff.applicativeAff))(Control_Monad_ListT.singleton(Control_Monad_Aff.applicativeAff)(_55.value0.value0))(Prelude["<>"](Control_Monad_ListT.semigroupListT(Control_Monad_Aff.applicativeAff))(unEvent(_985(_55.value0.value0)))(go(_55.value0.value1)));
                    };
                    throw new Error("Failed pattern match");
                })());
            }));
        };
        return go(_984);
    };
};
var altEvent = new Control_Alt.Alt(function (_995) {
    return function (_996) {
        return Control_Alt["<|>"](Control_Monad_ListT.altListT(Control_Monad_Aff.applicativeAff))(_995)(_996);
    };
}, function () {
    return functorEvent;
});
var plusEvent = new Control_Plus.Plus(function () {
    return altEvent;
}, Control_Plus.empty(Control_Monad_ListT.plusListT(Control_Monad_Aff.monadAff)));
var alternativeEvent = new Control_Alternative.Alternative(function () {
    return plusEvent;
}, function () {
    return applicativeEvent;
});
var monadPlusEvent = new Control_MonadPlus.MonadPlus(function () {
    return alternativeEvent;
}, function () {
    return monadEvent;
});
module.exports = {
    Event: Event, 
    andThen: andThen, 
    async: async, 
    "yield": $$yield, 
    runEvent: runEvent, 
    unEvent: unEvent, 
    semigroupEvent: semigroupEvent, 
    monoidEvent: monoidEvent, 
    functorEvent: functorEvent, 
    applyEvent: applyEvent, 
    applicativeEvent: applicativeEvent, 
    bindEvent: bindEvent, 
    monadEvent: monadEvent, 
    monadEffEvent: monadEffEvent, 
    monadAffEvent: monadAffEvent, 
    altEvent: altEvent, 
    plusEvent: plusEvent, 
    alternativeEvent: alternativeEvent, 
    monadPlusEvent: monadPlusEvent
};
