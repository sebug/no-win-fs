# Module Documentation

## Module Halogen.Component


This module defines a type of composable _components_.

#### `Component`

``` purescript
newtype Component p m req res
```

A component.

The type parameters are, in order:

- `p`, the type of _placeholders_
- `m`, the monad used to track effects required by external requests
- `req`, the type of external requests
- `res`, the type of external responses

Request and response types are public, but the component may also use an _internal_ type
of messages, as illustrated by the type of the `component` function.

The main interface to Halogen is the `runUI` function, which takes a component as an argument,
with certain constraints between the type arguments. This module leaves the type arguments
unrestricted, allowing components to be composed in various ways.

If you do not use a particular feature (e.g. placeholders, requests), you might like to leave 
the corresponding type parameter unconstrained in the declaration of your component. 

#### `component`

``` purescript
component :: forall p m req res. (Functor m) => SF1 req (HTML p (m res)) -> Component p m req res
```

Create a component by providing a signal function.

The signal function should consume external requests and produce DOM nodes. The DOM
nodes in turn will create (monadic) external requests.

See the `Halogen.Signal` documentation.

#### `component'`

``` purescript
component' :: forall p m req res i. SF1 (Either i req) (HTML p (m (Either i res))) -> Component p m req res
```

A variant of `component` which creates a component with some internal, hidden input type.

#### `widget`

``` purescript
widget :: forall eff req res ctx m. (Functor m) => { destroy :: ctx -> HTMLElement -> Eff eff Unit, update :: req -> ctx -> HTMLElement -> Eff eff (Maybe HTMLElement), init :: (res -> Eff eff Unit) -> Eff eff { node :: HTMLElement, context :: ctx }, id :: String, name :: String } -> Component (Widget eff res) m req res
```

Construct a `Component` from a third-party widget.

The function argument is a record with the following properties:

- `name` - the type of the widget, required by `virtual-dom` to distinguish different
  types of widget.
- `id` - a unique ID which belongs to this instance of the widget type, required by 
  `virtual-dom` to distinguish widgets from each other.
- `init` - an action which initializes the component and returns the `HTMLElement` it corresponds
  to in the DOM. This action receives the driver function for the component so that it can
  generate events. It can also create a piece of state of type `s` which is shared with the
  other lifecycle functions.
- `update` - Update the widget based on an input message.
- `destroy` - Release any resources associated with the widget as it is about to be removed
  from the DOM.

#### `mapP`

``` purescript
mapP :: forall p q m req res. (p -> q) -> Component p m req res -> Component q m req res
```

Map a function over the placeholders in a component          

#### `hoistComponent`

``` purescript
hoistComponent :: forall p m n req res. (forall a. m a -> n a) -> Component p m req res -> Component p n req res
```

Map a natural transformation over the monad type argument of a `Component`.

This function may be useful during testing, to mock requests with a different monad.

#### `runComponent`

``` purescript
runComponent :: forall p m req res r. (forall i. SF1 (Either i req) (HTML p (m (Either i res))) -> r) -> Component p m req res -> r
```

Unpack a component.

The rank-2 type ensures that the hidden message type must be used abstractly.

#### `install`

``` purescript
install :: forall p m req1 req2 res1 res2. (Functor m) => Component p m req1 res1 -> Component (Maybe p) m req2 res2 -> Component p m (Either req1 req2) (Either res1 res2)
```

Install a component inside another, by replacing a placeholder.

The placeholders labelled with `Nothing` in the second component will be replaced with the
first component. Placeholders labelled with `Just` will remain as placeholders.

#### `hide`

``` purescript
hide :: forall p m i req res. (Functor m) => Component p m (Either i req) (Either i res) -> Component p m req res
```

Hide some of the internal messages in a `Component`.

#### `combine`

``` purescript
combine :: forall p q r m req1 req2 res1 res2. (Functor m) => (forall a. HTML p a -> HTML q a -> HTML r a) -> Component p m req1 res1 -> Component q m req2 res2 -> Component r m (Either req1 req2) (Either res1 res2)
```

Combine two components into a single component.

The first argument is a function which combines the two rendered HTML documents into a single document.

This function works on request and response types by taking the _sum_ in each component. The left summand
gets dispatched to (resp. is generated by) the first component, and the right summand to the second component.

#### `functorComponent`

``` purescript
instance functorComponent :: (Functor m) => Functor (Component p m req)
```


#### `profunctorComponent`

``` purescript
instance profunctorComponent :: (Functor m) => Profunctor (Component p m)
```




